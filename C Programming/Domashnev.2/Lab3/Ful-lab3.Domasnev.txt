#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define ARR_SIZE 3
#define BLOCK_SIZE 7

/* 
Программа должна реализовывать следующие функции:
1.	Добавление новой записи в начало списка V
2.	Добавление новой записи в конец списка V
3.	Вставка новой записи на заданную позицию VV
4.	Удаление записи, находящейся на заданной позиции VV
5.	Изменение записи, находящейся на заданной позиции VV
6.	Очистка информационного массива V
7.	Последовательный поиск записи в информационном массиве V
8.	Вывод содержимого информационного массива на экран V
9.	Вывод служебных данных и текущей структуры используемой структуры хранения V
*/

// Объявим структуру данных информационного массива
typedef struct Data 
{
    char C1_key;
    int A[ARR_SIZE];
    char C2;
} Data;

// Определим узел блокового списка
typedef struct BlockNode
{
    int elCnt;
    Data LocalDataStore[BLOCK_SIZE];
    // Указатель на предыдущий блок
    struct BlockNode* next;
    // Указатель на следующий блок
    struct BlockNode* prev;
} BlockNode;

// Определим блоковый список
typedef struct BlockList
{
    int ElementCount;
    BlockNode* head;
    BlockNode* tail;
} BlockList;
void PrintElem(Data Elem)
{
	int j;
	printf("\n\t[\n\t\tC1_key: %c,\n\t\tC2: %c,\n\t\tA: [ ", Elem.C1_key, Elem.C2);
    for (j = 0; j < ARR_SIZE-1; j++)
    {
        printf("%d, ", Elem.A[j]);
    }
    printf("%d ]\n\t]", Elem.A[j]);
}
void DeclareList(BlockList* List)
{
    List->ElementCount = 0;
    List->head = NULL;
    List->tail = NULL;
}
// Приведение списка к состоянию инициализированного 
void DestroyList(BlockList* List)
{
    BlockNode* tmpNode = (BlockNode *)malloc(sizeof(BlockNode));
    tmpNode = List->head;
    while (tmpNode != NULL)
    {
        tmpNode = tmpNode->next;
        free(List->head);
        List->head = tmpNode;
    }
    List->ElementCount = 0;
    free(tmpNode);
}
BlockNode* findBlock(BlockList* List, int* p)
{
	BlockNode* curNode;
	if (*p > List->ElementCount / 2)
	{
		curNode = List->tail;
		*p = List->ElementCount - *p;
		while (*p >= curNode->elCnt)
		{
			*p -= curNode->elCnt;
			curNode = curNode->prev;
		}
		return curNode;
	}
	else
	{
		curNode = List->head;
		while (*p >= curNode->elCnt)
		{
			*p -= curNode->elCnt;
			curNode = curNode->next;
		}
		return curNode;
	}
}
void InitList(BlockList* List, Data newData)
{
	BlockNode* newNode = (BlockNode*)malloc(sizeof(BlockNode));
	
	newNode->prev = NULL;
	newNode->next = NULL;
	newNode->LocalDataStore[0] = newData;
	newNode->elCnt = 1;

	List->head = newNode;
	List->tail = newNode;
	List->ElementCount = 1;
}
// Добавление элемента в голову, в конец, на любую позицию.
void insToHead(BlockList* List, Data newData)
{
    int i;
	if (List->head == NULL)
	{
		// Если список пустой, я его инициализирую
		InitList(List, newData);
		printf("List was empty, list successefully initialized.\n");
	}
    else if (List->head->elCnt < BLOCK_SIZE)
    {
        // Новый элемент помещаю в нулевую позицию блока 
        for (i = List->head->elCnt - 1; i >= 0; i--)
        {
            List->head->LocalDataStore[i+1] = List->head->LocalDataStore[i];
        }
        List->head->LocalDataStore[0] = newData;
        List->head->elCnt++;
		List->ElementCount++;
	}
    else
    {
        BlockNode* newNode = (BlockNode*)malloc(sizeof(BlockNode));
        newNode->LocalDataStore[0] = newData;
        newNode->elCnt = 1;

        newNode->prev = NULL;
        List->head->prev = newNode;
    
        newNode->next = List->head;
		List->ElementCount++;
        
    }
}
void insToTail(BlockList* List, Data newData)
{
	if (List->tail == NULL)
	{
		InitList(List, newData);
		printf("List was empty, list successefully initialized.\n");
	}
    else if (List->tail->elCnt < BLOCK_SIZE)
    {
        // Если в хвостовом блоке списка еще есть место => Добавляю по индексу, равному количеству добавленных элементов
        List->tail->LocalDataStore[List->tail->elCnt] = newData;
        List->tail->elCnt++; List->ElementCount++;
	}
    else
    {
        // Если в хвостовом блоке нет свободного места
        BlockNode* tmpNode = (BlockNode*)malloc(sizeof(BlockNode));
        tmpNode->LocalDataStore[0] = newData;
        tmpNode->elCnt = 1;
        tmpNode->next = NULL;
        
        tmpNode->prev = List->tail;
        List->tail->next = tmpNode;
        // Теперь указатель на конец списка будет указывать на новый узел, указатель на предыдущий узел старого хвоста сохраняется. 
        List->tail = tmpNode;
		List->ElementCount++;
        
    }
}
// Вставка это именно вставка, а не изменение или не замена элемента на заданной позиции
void insToPos(BlockList* List, Data newData, int p)
{
    // Случай 1: индекс превышает число элементов в списке
    BlockNode *curNode;
    int elCnt = List->ElementCount, i;
    if (elCnt-1 < p)
    {
        printf("Number of elements in List = [%d]\nDesired item position: [%d]\nPosition is greated than Number of elements => newData will be inserted in the tail of the List\n", elCnt, p);
        // Переместить пользователя на ф-цию instToTail
		insToTail(List, newData);
    }
	else if (p == 0)
	{
		printf("Position (p) = [%d], p == [0]\n=> newData will be inserted in the head of the List\n", p);
		// Переместить пользователя на ф-цию insToHead
		insToHead(List, newData);
	}
	else
	{
		// Поиск нужного индекса
		// Идем по блокам и вычитаем из индекса количество фактическое количество элементов в каждом блоке, 
		// пока он не станет меньше количества элементов в рассматриваемом блоке
		
		// Случай 1: в блоке есть свободная ячейка
		curNode = findBlock(List, &p);
		if (p < curNode->elCnt - 1)
		{
			// В таком случае сдвигаю на 1 вперед все элементы после точки вставки, 
			// с элементом на этой позиции включительно
			for (i = p; p < curNode->elCnt-1; i++)
			{
				curNode->LocalDataStore[i + 1] = curNode->LocalDataStore[i];
			}
			curNode->LocalDataStore[p] = newData;
		}
		else
		{
			// В противном случае создаем новый блок и переносим туда все элементы начиная с p
			BlockNode* newNode = (BlockNode*)malloc(sizeof(BlockNode));
			
			newNode->prev = curNode;
			newNode->next = curNode->next;
			curNode->next->prev = newNode;
			curNode->next = newNode;

			newNode->elCnt = 0;
			// Теперь переносим из блока curNode все элементы, начиная с p в новый
			for (i = p; i < newNode->elCnt - p; i++)
			{
				newNode->LocalDataStore[newNode->elCnt] = curNode->LocalDataStore[i];
				curNode->elCnt--; newNode->elCnt++;
			}
			curNode->LocalDataStore[p] = newData;
		}
		List->ElementCount++;
	}
}
void rmFromPos(BlockList* List, int p)
{
	int i; BlockNode* curNode;
	// Удаляем один элемент в блоке
	// Если количество элементов в блоке > 1
	curNode = findBlock(List, &p);
	if (curNode->elCnt > 1)
	{
		for (i = p; i < curNode->elCnt - 1; i++)
		{
			curNode->LocalDataStore[i] = curNode->LocalDataStore[i + 1];
		}
		curNode->elCnt--;
	}
	// Если в блоке один элмент
	else
	{
		if (curNode == List->head)
		{
			curNode->next->prev = NULL;
			List->head = curNode->next;
		}
		else if (curNode == List->tail)
		{
			curNode->prev->next = NULL;
			List->tail = curNode->prev;
		}
		else
		{
			curNode->prev->next = curNode->next;
			curNode->next->prev = curNode->prev;
		}
		curNode->elCnt--;
		free(curNode);
	}
	List->ElementCount--;
}
// Линейный мноаспектный поиск
void findInList(BlockList *List, Data sArg)
{
	BlockNode *tmpNode = List->head;
	int fflag = 0, i, j, eqC = 0;
	while (tmpNode != NULL)
	{
		for (i = 0; i < tmpNode->elCnt; i++)
		{
			if (sArg.C1_key == tmpNode->LocalDataStore[i].C1_key && sArg.C2 == tmpNode->LocalDataStore[i].C2)
			{
				for (j = 0; j < ARR_SIZE; j++)
				{
					if (sArg.A[j] == tmpNode->LocalDataStore[i].A[j]) eqC++;
				}
				printf("eqC = %d\n", eqC);
				if (eqC == ARR_SIZE) 
				{
					PrintElem(tmpNode->LocalDataStore[i]);
					printf("\n");
				}
				fflag = 1;
			}
		}
		tmpNode = tmpNode->next;
	}
	if (!fflag) printf("Element not found :(\n");
}
void changeField(BlockNode* curNode, int p)
{
	int option;
	printf("Which field do you want to change?\n"
		"1 - First symbol\n"
		"2 - Second symbol\n"
		"3 - Array\n"
		"4 - Cancel\n");
	fflush(stdin);
	scanf("%d", &option);
	switch (option)
	{
	case 1:
		printf("Enter symbol: ");
		fflush(stdin);
		scanf("%c", &curNode->LocalDataStore[p].C1_key);
		break;
	case 2:
		printf("Enter symbol: ");
		fflush(stdin);
		scanf("%c", &curNode->LocalDataStore[p].C2);
		break;
	case 3:
		for (int i = 0; i < ARR_SIZE; i++)
		{
			printf("Enter element [%d] of array: ", i);
			fflush(stdin);
			scanf("%d", &curNode->LocalDataStore[p].A[i]);
		}
		break;
	default:
		printf("There is no such option. Operation canceled\n-- __ |*_^| __ --\n");
		break;
	}
}
void changeElement(BlockList* List, int p)
{
	BlockNode* curNode;
	int elCnt = List->ElementCount;
	if (elCnt - 1 < p)
	{
		printf("Number of elements in list is %d. You cannot change an element with index greater than %d\n", elCnt, elCnt - 1);
		return;
	}
	curNode = findBlock(List, &p);
	changeField(curNode, p);
}
// Генерация Списка, вызывается для только что объявленного списка
void GenList(BlockList* List, int N)
{
	Data newData;
	for (int i = 0; i < N; i++)
	{
		// Последовательно добавляю в хвост списка нвоые элементы
		newData.C1_key = rand() % 26 + 65;
		newData.C2 = rand() % 26 + 65;
		for (int j = 0; j < ARR_SIZE; j++)
			newData.A[j] = rand() % 1000;
		
		// Последовательно добавляю элементы в хвост списка
		insToTail(List, newData);
	}
}
void PrintList(BlockList* List)
{
	int i, j, c = 0;
	BlockNode* tmpNode = List->head;
	printf("tmpNode = %d", tmpNode);
	// Выполняю проверку на то что список только объявлен, но не заполнен значениями
	if (tmpNode == NULL)
	{
		printf("\nList is empty :(\n");
	}
	else
	{
		printf("\n--- BLOCK LIST---\nThe number of elements in the block list: %d\n", List->ElementCount);
		printf("tmpNode before while = %d\n", tmpNode);
		while (tmpNode != NULL)
		{
			printf("\nBlock Node No%c (elements: %d):\n[", c, tmpNode->elCnt);
			for (i = 0; i < tmpNode->elCnt-1; i++)
			{
				PrintElem(tmpNode->LocalDataStore[i]); printf(",");
			}
			PrintElem(tmpNode->LocalDataStore[i]); printf("\n]\n");
			tmpNode = tmpNode->next; c++;
		}
		printf("\n---The end---\n");
	}
}
Data GenNewData()
{
	Data newData;
	printf("Enter C1_key (1st character) : ");
	fflush(stdin);
	scanf(" %c", &newData.C1_key);
	printf("\nEnter C2 (2nd character) : ");
	fflush(stdin);
	scanf(" %c", &newData.C2);
	printf("\nLet's fill a mini-array:\n");
	for (int i = 0; i < ARR_SIZE; i++)
	{
		printf("[%d] el of array = ", i);
		fflush(stdin);
		scanf("%d", &newData.A[i]);
	}
	return newData;
}
void menu(BlockList* List)
{
	Data newData, sArg;
	int op = 10, p = 0;
	printf("Choose operation with block list\n"
               "1 -> Add an element to the beginning of the list\n"
               "2 -> Add an element to the end of the list\n"
               "3 -> Add an element to the position in the list\n"
               "4 -> Delete an element at the position in the list\n"
               "5 -> Change an element at the position in the list\n"
               "6 -> Destroy the list\n"
               "7 -> Search in the list\n"
               "8 -> Print the list\n"
               "9 -> Exit\n");
	fflush(stdin);
	scanf("%d", &op);
	switch (op)
	{
	case 1:
		newData = GenNewData();
		insToHead(List, newData);
		printf("newData is inserted to the head of the List\n");
		break;
	case 2:
		newData = GenNewData();
		insToTail(List, newData);
		printf("newData is inserted to the tail of the List\n");
		break;
	case 3:
		newData = GenNewData();
		printf("Enter index : ");
		fflush(stdin);
		scanf("%d", &p);
		insToPos(List, newData, p);
		break;
	case 4:
		printf("Enter index (NOTE: indexing starts from 0) : ");
		fflush(stdin);
		scanf("%d", &p);
		rmFromPos(List, p);
		break;
	case 5: 
		printf("Enter index : ");
		fflush(stdin);
		scanf("%d", &p);
		changeElement(List, p);
		break;
	case 6:
		DestroyList(List);
		break;
	case 7:
		printf("Let's create multi-aspect search argument\n");
		sArg = GenNewData();
		findInList(List, sArg);
		break;
	case 8:
		PrintList(List);
		break;
	case 9:
		printf("Goodbye (+_^)\n");
		break;
	default:
		printf("There is no such operation.\n");
		break;
	}
}
// Главная ф-ция
int main()
{
	int N; srand(time(NULL)); char isexit = 'N';
    // Под список выделяем память в главной ф-ции, там же очищаем
    BlockList* List = (BlockList*)malloc(sizeof(BlockList));
    DeclareList(List);
	printf("Enter number of elements : ");
	fflush(stdin);
	scanf("%d", &N);
	
	// Сформируем список из N случайных элементов типа Data
	GenList(List, N);
    
	// Вызовем меню столько раз, сколько пользователь пожелает.
	do {
		menu(List);
		printf("is exit? [Y/N] : "); 
		fflush(stdin);
		scanf(" %c", &isexit);
	} while (isexit != 89);

	// Сбор мусора
	DestroyList(List); free(List); return 0;
}