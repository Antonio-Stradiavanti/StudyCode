* Тг бот

- Бот :: Особая учетная запись, небольшое приложение, которое запускается внутри приложения Телеграм, используюет сообщения в качестве входных данных.
  + Главная ф-ция :: отправлять и получать сообщения.
    * Может писать в лс только тем пользователям, которые его запустили.
    * Отправляет запросы на Телеграм и получает от него обновления.
    * Пишутся на Java, js, python с использованием Telegram Bot API или Telegram API (используется больше для создания своего клиента Телеграм) И библиотек.

Создать и настроить бота можно через спец. бота BotFather, он выдает уникальный идентификатор бота, он используется для управления созданным ботом.

* Средство автоматизации сборки Gradle

Зависимость - внешний модуль (фреймворк, библиотека, плагин), необходимый на одном из этапов разработки ПО.
- Объявляется в блоке dependencies.

Конфигурация зависимости определяет этап разработки, на котором она будет задействована : компиляции, сборки, тестирования.

Чтобы объявить зависимость на языке gradle-groovy нужно :
1. Выбрать конфигурацию :
   - implementation :: Зависимость необходима на этапе компиляции. Включается в переменную среды окружения classpath.
   - compileOnly :: Зависимость необходима на этапе компиляции. Не включается в classpath.
2. Описать зависимость. Зависимость описывается 4 ключами : группы, имени и версии.

* Фреймворк Spring

! Установить на ubuntu можно с помощью команды ~apt install spring~, также нужно установить gradle.

** Терминология

- bean :: Компонент объектной модели JavaBeans.

- classpath :: Каталог, в котором осуществляется поиск классов.

- Spring Boot :: Расширение фреймворка Java Spring, используется для создания микросервисов. Предоставляет :
  1. Автоконфигурацию, механизм, который позволяет автоматизировать управление контекстом приложения.
  2. Автоматизацию сборки зависимостей
  3. Мониторинг времени выполнения.

- Микросервис :: Маленькая веб-служба выполняет определенные задачи И взаимодействует с другими веб-службами.
  + (разделяй и властвуй) Позволяют разбить большое, сложное монолитное приложение на маленькие, логически независимые модули, что существенно упрощает процессы : разработки, тестирования и развертывания.
  + Приложения на основе микросервисов размещаются в облаке.

- Вебхук == веб-перехватчик :: Механизм получения одним приложением в режиме реального времени информации о событиях, происходящих в другом приложении.
  + Сервер c вебхуком автоматически отправляет клиенту полезную информацию всякий раз когда на серверном приложении происходит определенное событие.
  + Использует протокол HTTP или HTTPS.
    * В целях защиты соединения полезные данные хешируют.

** ?> Зачем нужен Spring

Spring - фреймворк, позволяет автоматизировать управление зависимостями, упростить и ускорить процесс разработки современного ПО, предоставляет :
1. Механизм автоматического связывания компонентов проекта, основанный на использовании :
   a. Классов конфигурации
   b. Механизма сканирования (Spring обнаруживает компоненты в каталогах classpath).
2. Автоконфигурацию (анализирует classpath и переменные окружения)
Перечисленные механизмы экономят время программиста, позволяют ему сосредоточиться на функционале приложения.

В Spring boot проект интегрируют телеграм бота.

Spring создает контейнер == контекст приложения, в котором запускает компоненты приложения (службы) и управляет ими.
- Контекстом приложения управляют с помощью XML-файлов, так и с помощью спец. класса-конфигуратора.
  + В файлах XML описываются компоненты и их взаимосвязи с другими компонентами.

** ? Создание проекта

- Spring Tool Suite :: среда разработки на Spring, расширение для vs code.

- Spring Initializr :: Инструмент инициализации проекта на Spring Boot, Предоставляет REST API.

- Gradle :: Высокопроизводительный иструмент для автоматизации сборки приложений. Выполняется на виртуальной машине Java. Лучше чем Maven.
  + Зависимости добавляются в файл ~build.gradle~.
    - Зависимости :: Модули, библиотеки, необходимые для компиляции приложения.

    - Объявление зависимостей : 1 - в виде строки, 2 - в виде структуры, сост. из пар ключ-значение : группа, имя, версия.
    - Типы зависимостей : 1 - implementation -> используется только для компиляции приложения.


*** Метаданные проекта

1. Идентификатор группы должен соответствовать соглашениям Java о идентификаторах пакетов. Чтобы сформировать уникальный идентификатор пакета нужно использовать обратное доменное имя организации в качестве префикса для идентифкатора пакета.
   - Доменное имя :: Абстракция над ip адресом, состоит из корневого домена и одного или нескольких компонентов, разделенных точками.
     1. Корневой домен (TLD) % ru, uk, com, org.
     2. Один или несколько компонентов, следующих за корневым доменом. Последовательность от 1 до 63 символов (букв лат. алфавита, цифр и символа -).
2. Идентификатор информационного продукта == идентификатор jar без версии.
   - jar :: Архивный файл приложения на языке Java. Используется для хранения приложения Java в одном файле, состоит из скомпилированных в байт-код классов, списка ресурсов и ресурсов приложения.

Диспатчер используется для обработки потока сообщений из тг. Создается с помощью spring boot.

- Брокер сообщений :: Посредник между несколькими частями системы, обеспечивает ассинхронность обработки и распределения сообщений.

Базу данных реализуем на google sheets.

* Язык программирования Java [0/0] [0%]

- [ ] Разобраться с аннотациями

- var == auto В С++, компилятор сам определит тип значения выражения.

** Терминология

- Параметр - формальный параметр, агрумент - фактический параметр.
  + В стек-фрейме выделяется память для хранения локальных значений фактических параметров.

- Единица компиляции :: файл с исходным кодом Java.

- varargs parameter :: Параметр с переменным числом аргументов

** <2023-10-16 Mon> История языка

Java разработан из-за необходимости в архитектурно-нейтральном языке, на котором можно писать ПО, для бытовых электронных устройств.
  - Не обладает ни прямой, ни обратной совместимостью с С++, с создан для решения одних задач, С++ - для других.
  - С распространением интернета потребность в переносимом ПО только возросла, так как в сети необходимо и запускать одну и ту же программу на разных платформах.

В Java простой синтаксис и высокий уровень абстракции, НО нужно уметь использвать классы стандартных и сторонних библиотек.
Каждая программа на Java соответствует парадигме ООП.

Java чувствиетелен к регистру.

** <2023-11-15 Wed> Особенности языка и его отличия от С++

Все объекты являются ссылками, ссылка в Java это скрытый, неизменяемый указатель на объект.

Отсутствует возможность явного управления памятью => отсутствуют указатели. Памятью управляет сборщик мусора.
- Сборщик мусора автоматически освобождает память, занимаемую объектами, которые больше не доступны и не используются в программе.

Все объекты хранятся в динамической области памяти, которой управляет виртуальная машина Java (JVM).

a. Отсутствует автоматическое преобразование типов, несоответствие типов - ошибка времени компиляции.

b. Запрешено использование оператора безусловного перехода goto.

c. Индентификатор, вкл. ~-~ явл. недопустимым.

d. Все элементарные типы данных имеют строго определенный диапазон значений.

e. НЕТ беззнакового целого типа.

f. Для представления символов используется кодировка Unicode, первые 127 кодов выделены для символов кодировки ASCII.
   + => Тип char занимает 2 байта.


** ? Для чего сейчас применяется Java

Сечас Java в основном используется для написания сервлетов.

- Сервлет :: Программа, исполняется на сервере.
  + Используется для формирования динамически-создаваемого содержимого веб-страницы, на основе действий клиента (сервера), которая отправляется браузеру.

- , :: Означает список объявлений объектов одного типа.
- {} :: Групповой оператор, с его помощью объединяют от 2х инструкций в блоки.

** <2023-10-16 Mon> Байткод, JVM [0/1] [0%]

Байткод - Оптимизированный набор инструкций, предназнaченных для выполнения виртуальной машиной Java (интерпретатор байт-кода), которая является частью среды выполнения Java (JRE).

Использование виртуальной машины упрощает запуск программы на разных платформах, так как для каждой из них нужно реализовать только JVM, которая принимает один и тот же байт-код, это позволяет не переписывать компилятор для каждого типа процессоров.

Виртуальная машина позволяет создать ограниченную в ресурсах среду выполнения программы - песочницу, управляет выделенными ресурсами.

В состав JVM входит JIT компилятор для байт-кода, он позволяет скомпилировать во время выполнения (по запросу) часть байт кода в машинный код, с целью повышения производительности. Остальной байт-код интерпретируется.

** Скомпилировать и запустить программу на Java

*** Шилдт

> Скомпилировать -> вызывав для исходного файла компилятор ~javac~, Выполнить -> загрузить байткод в JVM, вызвать загрузчик ~java~.

Расширение файла с исходным кодом Java : ~.java~

- Программа javac :: Компилятор языка программирования Java, переводит исходный код на Java в инструкции виртуальной машины (байт код) Java.
  + Для каждого класса создает отдельный файл, с именем класса и расширением ~.class~.

- Программа java :: Программа запуска приложений Java, запускает среду выполнения Java, загружает указанный класс (файл с расшинением .class) в JVM. Метод main -> точка входа в программу, сост. из одного или нескольких классов.
  - Метод main должен :
    1. Быть открытым
    2. Быть статическим
    3. Принимать в качестве параметра массив типа String.
       + Хранит любые аргументы командной строки.


** Ввод и вывод

*** Ввод

**** Шилдт

Класс Scanner содержится в пакете java.util, считывает текст из источника, который реализует интерфейс Readable, разбивает текст на лексемы по заданным разделителям и преобразует их в значения с помощью методов next ИЛИ с помощью регулярных выражений, определяющих формат входных данных.

*** Вывод

**** Шилдт

- Статический метод println() :: Принимает строку, к строке можно добавить переменную элементарного типа с помощью перегруженного оператора ~+~, вставляет символ новой строки в поток вывода;
  + Если строка, добавленная в стандартный поток вывода не оканчивается символом новой строки, то следующая строка добавится в ту же строку стандратного потока вывода.

- print :: не вставляет символ новой строки в поток вывода.
** <2023-11-15 Wed> ООП

*** Классы

Класс определяет новый, аггрегатный тип данных.
Компилятор Java автоматически помещает каждый класс в отдельный файл с расширением ~.class~.
- Имя класса, содержащего метод ~main()~ должно совпадать с именем исходного файла вплоть до регистра.

Свойства == переменные экземпляра, каждый объект хранит свою, независимую копию этих переменных.

Метод ~main~ объявляется в классе для объявления точки входа в программу.

Оператор ~new~ исп. как и в С++ выделяет динамическую область памяти под объект и возвращает ссылку (адрес) на неё.

- В Java все объекты хранятся в динамической области памяти.
- Объявление переменной некоторого типа (без инициализации) есть объявление ссылки на соответсвующий тип.

Оператор ~.~ исп. для доступа к членам объекта.

**** Конструктор

Если конструктор по умолчанию не определен, то компилятор сгенерирует стандартный конструктор, который вызовет конструктор по умолчанию для свойств экземпляра класса.

*** Перечисления

- Перечисление :: Особый класс, список именованных констант, объект перечисления может содержать только значения из списка значений, указанных при объявлени. Удобно использовать в операторе switch.
  + В Java перечисление может иметь конструктор и методы


** Синтаксис

После выполнение оператора return управление передается обратно вызывающей программе, из стека удаляется соответсвующий стек-фрейм.

*** <2023-11-14 Tue> Type Wrappers (Обертки типов)

Примитивные типы в Java, в целях повышения эффективности использования ресурсов реализованы также как в С++, это именованные области памяти, доступные для записи и чтения, но библиотечные классы и алгоритмы работают только с объектами, таким образом в некоторых ситуациях необходимо объектное представление примитивных типов.

- Обертка типа (Type Wrapper) :: Объектное представление примитивного типа (инкапсулирует переменную примитивного типа и предоставляет методы для работы с ним).

- Doube, Float, Long, Integer, Short, Byte, Character, Boolean.

Иниициализировать объект одного из классов type wrapper можно либо с помощью статического метода ~valueOf()~, либо с помощью оператора ~=~, они принимают в качестве параметра литерал соответствующего примитивного типа.

Вообще нет необходимости явно создавать объект семейства классов type wrapper, так как компилятор Java предоставляет механизмы автоупаковки и автораспаковки, которые он выполняет всякий раз, когда примитивный тип должен быть преобразован в объект, и наоборот.


*** <2023-11-14 Tue> Аннотации

**** Шилдт & Chat GPT

- Аннотация :: Механизм *метаданных*, Дополнительная информация, включаемая в исходный код, которая не меняет семантику программы, но используется компилятором, анализатором кода и другими средствами автоматизации сборки или развертывания. Аннотировать можно любой тип объявлений языка. Аннотация (как и шаблон в С++) предшествует остальной части объявления.

  1. Для объявления используется ключ слово ~@interface~. Объявление аннотации по синтаксису сходно с объявлением класса, т.е. : объявление аннотации должно содержаться в одноименном исходном файле.
     * Аннотации состоят только из объявлений виртуальных методов.
     * Являются производными от интерфейса Annotation.

     #+BEGIN_SRC java
     /* Как объявить пользовательскую аннотацию в Java */
     @Target(ElementType.TYPE)
     // Перечисление ElementType указывает тип аннотации.
     @Retention(RetentionPolicy.RUNTIME) // в скобках указывается список инициализаторов членов, каждый инициализатор присваивается соответствующему члену.
     public @interface NewAnnotation {
     }
     #+END_SRC

  2. Объявление аннотации - объявление особого класса.

Аннотация ~@Override~ явно указывает компилятору что метод переопределяет метод базового класса.

Аннотация ~@Target~ применяется к пользовательским аннотациям и явно указывает тип объявлений языка, к которому можно применять данную аннотацию.

Аннотация ~@Retention~ устанавливает политику хранения пользовательской аннотации, которая определяет этапы на которых будет доступна аннотация.

- Внутри _перечисления_ ~RententionPolicy~ инкапсулированны 3 *политики хранения* : SOURCE, CLASS, RUNTIME.
  + CLASS :: успользуется по умолчанию, аннотация доступна в исходном коде и на этапе компиляции.
  + RUNTIME :: Обеспечивает доступность аннотации в исходном коде и во время компиляции и выполнения.
    * Информацию об аннотациях класса с такой политикой хранения можно запрашивать из других программ на Java посредством рефлексии.

- Рефлексия :: Средство, позв. получать информацию о классе во время выполнения.




*** <2023-11-03 Fri> Пакеты -> объявление и импорт

Оператор ~package~ определяет пространство имен для всех классов, объявленных в данном исходном файле
- Если оператор ~package~ отсутствует, то идентификаторы классов помещаются в стандартный безымянный пакет.
Для хранения пакетов применяют каталоги имя каталога должно совпадать с именем пакета вплоть до регистра.
- Иерархия пакетов также должна быть отражена в файл. системе.

Пути к каталогам, содержащим пакеты нужно указать в переменной среды окружения ~classpath~ или в параметре загрузчика ~java -classpath~
