* Спецификация
- Цель работы :: Изучить механизм параметрического полиморфизма на основе создания и использования параметризованных классов.

- Задание кафедры :: Реализовать на С++ параметризованный класс "Матрица"
  + Типы элементов матрицы : множество объектов определенного типа, массив символов.
  + Необходимые операции : сложение матриц, разность матриц, сложение матрицы с символом (добавить символ к каждому из элементов), сложение символа с матрицей (та же операция, только порядок опреандов другой).
    * Операции осуществляются одной строкой.

* Ход работы

- Компилятор всегда инициализирует нулем переменные базовых типов (имитация конструктора по умолчанию).

** Шаблонная ф-ция

Ф-ция, может работать с объектами различных типов, использует типы в качестве параметров. С помощью параметров обобщают тип возвращаемого значения или типы формальных параметров.

Указать компилятору использовать значение шаблона по умолчанию можно с помощью пустых фигурных скобок.

** Объявление дружественной шаблонной ф-ции

1. Объявляем дружественную шаблонную функцию, если объявить перегруженный оператор вставки в поток в качестве простой дружественной ф-ции, то он сможет принимать в качетсве параметра только экземпляр класса Test типа T. Но это не самое лучшее решение с точки зрения безопасности.
#+BEGIN_SRC C++
template <typename T>
class Test {
   template <typename U>
   /* Объявляем дружественными функциями весь перечень ф-ций, созданных на основе этого шаблона. */
   friend std::ostream& operator<<( std::ostream&, const Test<U>& );
};
template <typename T>
std::ostream& operator<<( std::ostream& o, const Test<T>& ) {
   // Can access all Test<int>, Test<double>... regardless of what T is
}
#+END_SRC

** TODO Как добавить элемент в вектор экземпляров класса не используя указатели (Йосуттис)

! Чтобы инициализировать ячейку вектора прямо (без копирования) (как если бы использовал указатели) используй метод ~emplace_back()~.

Векторы можно сравнивать, тогда логическая операция будет вызываться для каждого из элементов

Универсальный конструктор :
#+BEGIN_SRC C++
    vector <Elem> v (n /* количество_элементов */, elem /* конструтор_для_каждого_из_них */) ;
#+END_SRC
- Если в универсальный конструктор передать только количество элементов n, то для каждого из n элементов будет вызван конструктор по умолчанию.

При удалении вектора фактический объем выделенной памяти не изменяется, поэтому соответствующая операция называется ~erase~.

Конструктор с итераторами копирует n-1 элементов из вектора v0 в вектор v1.
#+BEGIN_SRC C++
    vector <Elem> v1 (v0.begin() /* количество_элементов */, v0.begin() + n /* конструтор_для_каждого_из_них */) ;
#+END_SRC

*** Информация об объеме выделенной памяти и о количестве элементов

- capacity() :: Объем выделенной под вектор памяти (в количестве элементов).

*** Управление объемом памяти

- reserve(int n) :: Выделяет область памяти под n элементов, если n <= v.capacity(), то не делает ничего. Не инициализирует выделенную область памяти.

*** Задание новых элементов

- assign() :: Заменяет определенное множество старых элементов новыми.
  + Множество методов assign соответствует множеству конструкторов.

*** Прямой доступ к элементам

- at(i) :: Возвращает ссылку на элемент, с индексом i, вызывает исключение ~out_of_range~, если входной индекс не принадлежит множеству допустимых индексов вектора.

** Статические поля

- Статичское поле видимо только внутр
  и класса, время жизни == время работы программы.
  + Используются для хранения данных, совместно используемых объектами класса.
  #+BEGIN_SRC C++
    // Пример инициализации статического поля
    class foo { static int bar }; int foo::bar = 10;
  #+END_SRC

** Значения формальных параметров ф-ции по умолчанию

- Используются тогда когда при вызове ф-ции в списке фактических параметров отсутствуют значения этих
  параметров. Альтернатива наличию нескольких перегруженных ф-ций.
  + Определять значения по умолчанию можно лишь для крайних параметров в списке формальных параметров.

** Генератор псевдослучайных чисел. с специальным идентификатором особым


(Левый операнд вызывает операторную ф-цию, пый перегруженный методвый (метод)передаенее. ф-цию
.7) у Страусегоупа


- random number :: Случайная величина
- Левый операнд вызывает операторную ф-цию, пandoый методвый операнд пернее.рную ф-цперегруженный ию
numb (метод с специальным идентификатором особым
) :: Генератор псевдослучайных чегоел.
- seed :: Начальная конфигурация генератора случайных чисел, параметр алгоритма.


- Как работает генератор псевдослучайных чисел

- Какой из генераторов использовать в С++ ?
  + Левый операнд вызывает операторную ф-цию, пеализациый методвый операнднее.раторную ф-цию с специальным идентификатором особым
 одного иперегруженный з законо (метод)еления НСВ, инициализировать коегорый можно с помощью random_device.
    * Равномерное распределение можно использовать для генерации случайных чисел в заданном диапазоне.


  + Генератор mt19937

Для того чтобы реализовать универсальный метод, который позовляет использовать символ как левым, так и правым операндом перегружаемого для матрицы оператора + нужно исп. друж ф-ции.


* Контрольные вопросы
** Терминология

- Параметрический полиморфизм :: Механизм, который позволяет использовать типы в качестве параметров ф-ции или класса.

- std::vector :: Динамический массив элементов типа Т с операциями, существенно облегчающими работу с динамической память.

** ? Зачем нужны параметризованные классы

Для создания обобщенных типов, которые могут работать с различными типами данных.

** ? Какой из механизмов ООП реализуется с использованием параметризованных классов

Параметрический полиморфизм.

** ? Что такое шаблон класса

Механизм, который позволяет использовать типы в качестве параметров класса, для обобщения определенных свойств или методов класса, по этим параметрам компилятор во время компиляции сгенерирует конкретный класс.

** ? Во сколько раз сокращается машинный код программы при использовании параметризованных классов

Введение шаблона сокращает лишь размер исходного кода, машинный код генерируется компилятором для каждой специализации каждого шаблона.

** ? Какого вида могут быть параметры при задании шаблона класса

1. Типы, объявляются с помощью ключ. слов ~class~ или ~typename~, могут принимать значение по умолчанию.

2. Не типы : числа, массивы, указатели на ф-ции, указатели и сслыки на экземпляры классов. Чаще всего используются объекты классов билблиотеки ~type_traits~ и ~std::array~.

3. Вложенные шаблоны типов

** ? Контейнеры
- Контейнер последовательности :: упорядоченная коллекция, в которой каждый элемент занимает определенную позицию, которая не зависит от значения элемента.
  + В STL : array, vector, deaue, list, forward_list.
