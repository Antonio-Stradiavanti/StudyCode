  #+TITLE: Реализовать на С++ концепцию векторной ф-ции скалярного аргумента (с привлечением механизма наследования и виртуальных ф-ций).
* TODO Написать код
  ** TODO Написать структруру базового класса, выполнить наследование
  - [X] Разобраться с ключ. словом virtual.
  - [X] Сформировать вектор из ф-ций выранных пользователем ф-ций пользовательского размера.
  - [X] Сделать красивый вывод для каждого из производных классов.
    + Для этого : класс должен хранить параметры ф-ций.
  - [X] Для универсальности и расширяемости Хранить параметры и результат выражение в классе.  
  - [ ] Выполнить обработку ошибок ввода с помощью regex и исключений.
    + getline() -> Считывает строку из потока ввода.
* TODO Ответить на контрольные и вознишие в ходе выполнения работы вопросы. Начал : <2023-10-10 Tue>
** DONE ?! Зачем нужен механизм наследования.
- Наследование :: Механизм, который позволяет описать класс на основе уже существующего, с частично или полностью заимствованной функциональностью.
  + Режимы наследования в С++ :: открытый : открытые члены базового класса остаются открытыми в производном классе, закрытый : все члены базового класса становятся закрытыми членами производного класса, защищенный : все открытые члены базового класса становятся защищенными членами производного класса.
- Для создания иерархической структуры классов, которая позволяет достичь оптимального управления моделью реального объекта. Для этого на каждом иерархическом шаге учитываются только изменения, чтобы не дублировать свойства и методы, учтенные на предыдущих шагах.
** DONE ?! Зачем нужен механизм полиморфизма И какие сущ. виды полиморфизма, к какому из видом полиморфизма относится перегрузка оператора
- [X] Дать понятное определение полиморфизма, опираясь на лекцию Ведуна.
- Полиморфизм реализует принцип "один интерфейс - множество реализаций". Механизм полиморфизма позволяет использовать один интерфейс для "класса" операций, а также использовать объекты с одинаковым интерфейсом, не имея информации об их типах и внутренней структуре. Виды полиморфизма :
  + Статический (времени компиляции) == параметрический :: Позволяет использовать : *один и тот же набор инструкций* ИЛИ *один оператор* для выполнения разных операций C объектами разных типов, достигается с помощью шаблонов классов и ф-ций, и перегрузки методов и операторов.
    - Шаблон :: Механизм, позволяющий программисту использовать типы в качестве параметров класса или ф-ции. По этим параметрам компилятор формирует конкретный класс или ф-цию (происходит макроподстановка).
  + Динамический (времени выполнения) :: Позволяет производным классам переопределять соответствующие методы базового класса, и вызывать соответствующий производному классу метод с помощью указателя на баз. класс.
    + Достигается с помощью виртуальных ф-ций, ==реализующих механизм связывания во время выполнения (late binding)==, что позволяет пользователю, вызывая метод базового класса, вызывать для каждого производного класса свою реализацию этого метода.
    + Для того чтобы определить конкретную реализацию метода базового класса компилятор добавляет каждому из объектов производных классов указатель на таблицу виртуальных ф-ций (определяется для каждого класса с виртуальными функциями), в которую в свою очередь на этапе выполнения записывается адрес конкретной реализации.
      + Если метод базового класса не переопределен в производном классе, то в таблице объекта производного класса будет записан адрес реализации этого метода в базовом классе, иначе -> адрес реализации производного класса.
      + Таким образом для вызова виртуальной ф-ции требуются всего два обращения к памяти (1. доступ к таблице, 2. смещение в этой таблице и доступ к адресу реал. конкретной ф-ции) и обычный вызов ф-ци.
** TODO ?! Что такое интерфейс класса
** TODO ?! Зачем нуже чисто виртуальный метод
** TODO ?! Какой класс называется абстрактным
** TODO Повторить концепции
- [ ] Дружественные классы и ф-ции
- [ ] Статические методы и свойства.
- [ ] Конструктор перемещения
