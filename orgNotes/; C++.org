#+startup: num
#+startup: overview

"Будь проще" - Бьерн Страуструп
- Классы в идеале должны быть маленькими и простыми.

- Избегай использование глобальных переменных, так как трудно понять какая из ф-ций оперирует ими.

* Терминология

- lvalue :: именованный объект, то что стоит в левой части оператора присвания.

- rvalue :: неименованный временный объект, то что стоит в правой части оператора присваивания, то что возвращает ф-ция.

- Пробельный символ \n :: Конец строки.

- Процедурное программирование :: Программа строится в терминах типов и ф-ций.

- Базовые типы ~ встроенные типы

- Препроцессор :: программа, часть компилятора выполняет первичную обработку и преобразование текста программы, выполняя директивы.

- Заголовочный файл :: Набор объявлений.
  + Директива препроцессора ~#include~ просто копирует объявления из файла в то место где она указана.
  + Нужно включать как в исходные файлы, использующие объявления, так и в исходные файлы содержащие определения.

Встроенные типы НЕ инициализируются по умолчанию, то есть им нужно явно присвоить начальное значение.

- Класс vector нужно использовать для хранения объектов в куче, а класс array - для хранения объектов в стеке или в сегменте данных.
  + Класс array в отличие от массивов является *безопасным с точки зрения прямого доступа*, так как хранит размер внутреннего массива, что позволяет предотвратить выход за границы множества индексов.

Использование указателей обеспечивает гибкость и эффективность программ.

Документацию алгоритмов и классов STL читай на [[https://en.cppreference.com/w/][cppref]]


* DONE ? Стандарты С++

- mature :: Созреть, сформироваться

- C++11 :: Второй ISO стандарт языка С++. В нем описывается синтаксис языка и возможности стандартной библиотеки. Кто угодно может предложить новые ф-ции и расширения стандартной библиотеки, но чтобы они стали частью языка, они должны быть приняты всей организацией по стандартизации.

* Область видимости, пространства имен.

[ :: ] = Оператор глобального разрешения.

* Операторы приведения типов

<<<<<<< HEAD:Notes/; C++.org
* Работа с потоками

=======
- const_cast<тип>(выражение) :: Позволяет убрать квалификатор const из типа выражения.

- static_cast<тип>(выражение) :: Используется для приведения типов (чаще всего для приведения вниз по иерархии наследования указателя на базовый класс), не убирает квалификатор const.
  + Можно использовать для приведения целого числа к типу перечисления.

* Работа с потоками

- Поток :: абстракция, последовательность байт или символов, разделенных на строки, связанна либо с ПЗУ, либо с периферийным устройством.
  + Поток ввода :: Данные передаются от устройства ввода в память.
  + Поток вывода :: Данные передаются из памяти к устройству вывода.

- Форматированный ввод/вывод :: Преобразование объектов базовых типов в поток символов или из потока в объекты базовых типов.

cout -> глобальный объект специализированного класса ~std::ostream == std::basic_ostream<char>~, в котором определены высокоуровневые операции над потоками символов

>>>>>>> refs/remotes/origin/main:orgNotes/; C++.org
Средства библиотеки ввода/вывода обращаются в к устройствам ввода/вывода с помощью драйверов.

Входные/выходные с точки зрения пользователя - абстракция, поток байтов, позволяет пользователю считывать и записывать данные на различные устройства ввода/вывода. Передача байт с устройство на устройство находится в компетенции драйверов.

Класс ~ostream~ представляет потоки вывода, преобразует значения различных типов в последовательности символов, отправляет их на другое устройство (диск, консоль, ...).

Класс ~istream~ представляет потоки ввода, составляет из последовательности символов на диске объект.

Аналог формата файлов на диске - тип данных в оперативной памяти.

Поток ~ifstream~ используется для чтения данных из файла, поток ~ofstream~ используется для записи в файл.

Открытие файла выполняется неявно, когда вызывается конструктор объекта потока.

Закрытие файл выполняется неявно, когда вызывается деструктор объекта потока ввода/вывода. Деструктор потока ввода/вывода сбрасывает связанный с ним буфер (последовательность байт из буфера записываются в файл).

Открыть и закрыть поток можно и явно, выполняя методы ~open()~ и ~сlose()~



* Ф-ции, методы и стек

Имена формальных параметров при объявлени ф-ций не являются обязательными.

Если ф-ция не должна изменять значение параметра то сделай его неизменяемым.

Возврат значения - вид инициализации.

Значения примитивных типов И маленькие объекты можно передавать в ф-ции по значению, экземпляры классов лучше передавать по неизменяемой или изменяемой ссылке.

Следует возвращать результат, а не модифицировать объект, передаваемый по ссылке.

Ф-ция может возвращать только одно значение с помощью оператора return.

Объявленная как constexpr ф-ция выполняет все вычисления и возвращает результат во время компиляции, должна состоять из одной инструкции return.

** <2023-12-14 Thu> Удаленные ф-ции

Синтаксис:
#+BEGIN_SRC cpp
class Sample {
public:
   Sample(const Sample&) = delete;  // Запрещаем компиляцию вызовов конструктора копирования и копирующего оператора присваивания
   Sample& operator= (const Sample&) = delete;
};
#+END_SRC

Используются чтобы запретить вызов определенных ф-ций, чаще всего сгенерированных компилятором.

Удаленной может быть любая функция, включая функции, не являющиеся членами, и специализации шаблонов.


** <2023-10-19 Thu> Дружественные ф-ции

- Объявление друж. ф-ции ИЛИ агрегатного типа данных :: механизм, благодаря которому ф-ция или класс могут получить доступ к *закрытым и защищенным* членам класса, в котором ф-ция или класс объявлены дружественными с помощью ключ слова ~friend~.
  ~ Ф-ция, которая оперирует объектами разных классов.


* Синтаксические особенности соверменного С++

Директива using часто используется для объявления псевдонимов типов.

В С++11 ввели перечисления с областью видимости, особенности :
1. Гораздо строже типизированы их аналогов из С, т.е. : _не преобразуются неявно в целочисленные типы_
2. Для них тоже можно явно задать базовый тип, _базовым типом по умолчанию является int_ => они могут быть предварительно объявлены.
#+BEGIN_SRC C++
enum class имя_перечисления {
  /* ... */
};
#+END_SRC



* Область видимости, вложенные классы и пространства имен

- Модуль :: Подпрограмма с изолированным лексическим контекстом, который определяет область видимости для объявлений внутри него.

- Область видимости (Scope) :: Область объявлений,  введена для того чтобы обеспечить локальность идентификаторов объявлений, для удобства программиста, чтобы ему не приходилость каждый раз выдумывать уникальные идентификаторы.

- Пространство имен (namespace) :: Именованная область видимости, вложенная в глобальную область видимости исходного файла или в другое пространство имен.
  + Объявление класса определяет именованную область видимости.
  + Позволяет сгруппирвоать классы, ф-ции и данные.

*Блок* (совокупность инструкций, заключенных в фигурные скобки) ИЛИ *список параметров ф-ции* - определяет локальную область видимости.

Инструкция for, while имеет свою область видимости.

Переобъявление в некотором вложенном блоке скрывает исходное обьявление во внешнем блоке.

Объявление вложенного класса допустимо только в сложных классах.
- Вложенные классы являются открытыми членами.


* Указатели, ссылки, итераторы -> динамически распределяемая область памяти

- nullptr :: Указатель любого типа, его - ~nullptr_t~ неявно преобразуется во все типы обычных указателей. nullptr используют в С++ Из-за того что он в отл. от NULL является строго типизованным.

** <2023-10-27 Fri> C++11 Ссылки, семантика перемещения и указатель this.
*** Советы

- Используй бумагу чтобы проверить логику работы программы на локальном примере.

- Объекты, занимающие малый объем памяти лучше передавать в ф-цию по значению.

*** Ссылки и указатели по разному работают с адресами.
- Никогда не возвращай ссылку на объект, хранящийся в куче, т.к нельзя получить доступ к значению ссылки и следовательно освободить память, выделенную под этот объект.

**** Страуструп

Для неизменяемой ссылки lvalue (объект, хранящий значение) не требуется.
- Если передавать rvalue то компилятор создаст временный объект.

- Ссылка (в зависимости от контекста) :
  + Автоматически разыменовываемый неизменяемый указатель
  + Альтернативное имя объекта

- После инициализации ссылку невозможно связать с другим объектом.
- Невозможно получить доступ к адресу ссылки

**** Дьюхерст

- С помощью ссылок можно дать удобное имя неименованным объектам чтобы упростить работу с ними И не создавать лишних объектов.


** <2023-11-01 Wed> Итераторы

*** (20. -4) Страуструп

Итератор end() указывает на элемент следующий за последним для реализации проверки контейнера на пустоту.
- Если ~c.begin() == c.end()~, то контейнер пуст.

*** (6.3) Йосуттис

Итераторы введены для обеспечения общности вычислений над разными контейнерами, чтобы хранить индекс искомого элемента в контейнере.

- Итератор :: Объект, представляет положение элемента в контейнере.

** Оператор new -> Выделяет память

! Возвращает указатель на адрес первого байта выделенной области памяти.

- Синтаксис :: для объекта : ~new Тип{Список инициализации}~, для массива объектов : ~new Тип[размер]{список_инициализаторов}~.

** Оператор delete -> Освобождает память

- Синтаксис :: для объекта : ~delete Указатель~, для массива объектов : ~delete[] Указатель~.



* ООП
#+BEGIN_SRC C++
{
    T t0, t1, t2; // Вызов конструктора по умолчанию
    T t1 = t0 // Вызов копирующего конструктора
    t2 = t1; // Вызов метода operator=()
}
#+END_SRC

! Указатели на базовый и производный класс совместимы по типы, НО базовый и производный классы не совместимы по типу.

Класс должен поддерживать копирование или явно запрещать его

Конструктор по умолчанию нужен тогда когда нужно создать экземпляры без указания инициализатора.

** Отношения

- Аггрегация :: Объект класса A является свойством класса B.

** Указатель this

*** Ведищев

Указатель this сожержит адрес байта, начиная с которого размещены свойства экземпляра класса.

*** Страуструп

- Хранит адрес объекта, для которого вызван метод. Неявно используется при каждом обращении к полю класса из метода.

- Вызывается явно когда нужно обратиться ко всему объекту.


** <2023-10-24 Tue> Деструкторы

Деструктор вызывается :
1. Программа завершает работу
2. К указателю применяется ~delete~
3. Объект вызодит за пределы области видимости (блока в котором он объявлен).

Если производный класс может иметь деструктор, то в базовом классе должен быть определен виртуальный деструктор.

Если класс содержит явно определенный деструктор то он использет ресурсы => в нем должны быть определены для реализации глубокого копирования :

1. Конструктор копирования
2. Копирующий оператор присваивания
3. Конструктор перемещения
4. Перемещающий оператор присваивания.

*** Различие между круглыми и фигурными скобками при создании объекта.

- aggregate :: Агрегатный тип данных - массив; класс, структура или объединие, которые не являются базовыми и в которых нет : конструкторов, закрытых или защищенных полей, виртуальных методов.
  + Агрегатный тип данных можно тоже можно инициализовать списковой инициализацией (с помощью фигурных скобок) (aggregate initialization) (указать в них последовательно через запятую значение каждого из полей).

~initializer_list<T>~ -> Список элементов типа T.

**** Списковая инициализация ~ унифицированный стиль инициализации ~ инициализация в фигурных скобках {}

***** Инициализация :

- При использовании в списке инициализаторов конструктора.

- Выполняется инициализация агрегата, если объект агрегатного типа данных.

- Вызывается соответствующий конструктор.

- ЕСЛИ список инициализации пустой ТО выполняется инициализация значением, вызывается конструктор по умолчанию
  * Базовые (скалярные) типы инициализируются нулем.

***** Присваивание :
- Список инициализаторов rvalue оператора присваивания.

- Возврат значения из ф-ции (вызывается конструктор копирования или оператор присваивания)

**** Скот Мейерс

- Фигурные скобки используются для явного вызова конструктора по умолчанию (без параметров)

- С помощью фигурных скобок можно указать значение поля класса по умолчанию.

- Инициализация в фигурных скобках позволяет предотвратить неявные сущающие преобразования.

- Для того чтобы отличить синтаксически отличать присваивание от инициализации в стандарте С++11 введена синтаксическая конструкция "список иницилизаторов". Список инициализаторов заключается в фигурные скобки (braces).

**** Страуструп

- Знак равенства перед списком инициализации опускают.

- При инициализации в фигурных скобках конструктор, принимающий ~std::initializer_list<параметр_шаблона>~ имеет для компилятора приоритет выше чем все остальные.
  + Классы с таким конструктором : ~vector~, ~array~.

** <2023-11-10 Fri> Конструктор копирования и копирующий оператор присваивания

Конструктор копирования принимает неизменяемую сслыку на экземпляр того же класса
- Поскольку ссылка на rvalue является универсальной и может принимать lvalue то модификатор const позволяет компилятору отличить конструктор копирования от конструктора перемещения к тому же конструткор копирования не меняет копируемый объект.

Вызывается при инициализации одного объекта другим объектом того же типа.
- В качестве аргумента принимает не изменяемую ссылку на подлежащий копированию объект. ~T(const T&){//}~

*** Копирование

Копирование по умолчанию выполняется поэлементно.

Для встроенных типов синтаксически (но не технически) определены копирующие конструкторы по умолчанию, вызов которых компилятор переводит в простую инициализацию переменной указанным в скобках (фигурных ИЛИ круглых) значением.

- Поверхностное копирование :: Происходит копирование адреса, таким образом 2 указателя указывают на один объект.

- Глубокое копирование :: Происходит копирование информации на которую указывает указатель.
  + для реализации глубокого копирования в пользовательском классе необходимо явно определить конструктор копирования и оператор присваивания.



** Конструктор перемещения и перемещающий оператор присваивания


*** std::move, std::forvard

Ф-ция ~std::move()~ приводит ~lvalue~ к ~rvalue~. Необходимо вызвать в конструкторе перемещения так как внутри rvalue преобразуется в lvalue.

Позволяет эффективно перемещать большие объемы информации.
- При перемещении исходный объект становится пустым.

Вызывается в момент иницализации объекта возвращаемым ф-цией значением.

Конструктор перемещения принимает ссылку на rvalue.


*** Универсальная ссылка
Ссылка на rvalue ~T&& r = foo();~

+ ~T&&~ :: Ссылка на rvalue (значение которое стоит в правой части оператора присваивания).
#+BEGIN_SRC C++
    vector(vector&&); // Конструктор перемещения
    vector(const vector&); // Конструктор копирования
#+END_SRC



** TODO <2023-10-12 Thu> Полиморфизм

В процессе разрешения перегрузки конструкторов список инициализаторов в фигурных скобках соответстввует параметрам конструктора, с параметром типа ~std::initializer_list~

*** Параметрический полиморфизм -> Шаблоны - Позволяет использовать единый интерфейс, определяемый классом, для работы объектами, хранящими или обрабатывающими объекты разных, более элементарных, типов. Полезно сочетать с динамическим полиморфизмом.

**** Страуструп 💿

Используются для создания гибких и высокопроизводительных программ (параметрический полиморфизм более производительный чем динамический полиморфизм)

- Обобщенное программирование == Алгоритмически ориентированное программирование :: Процесс создания кода, работающего с разными типами, заданными в виде параметров, эти типы должны соответствовать специфическим синтаксическим и семантическим требованиям.

  + Сначала следует разработать и протестировать класс, используя конкретные типы, а потом заменить их параметром шаблона.

- Шаблон :: Механизм, который позволяет использовать типы в качестве параметров ф-ции или класса.

  + По этим параметрам компилятор генерирует конкретный класс или ф-цию (выполняет макроподстановку).
    * Специализация :: Процесс создания классов/ф-ций из шаблона класса/ф-ции по заданным параметрам шаблона. Осуществляется на этапе компиляции или на этапе компоновки.
    * Параметризация :: Подстановка конкретного типа в шаблон.

  1. Шаблон класса == генератор типов -> Позволяет обобщать тип определенных его свойств или методов.

    * Для объявления типа параметра шаблона используются ключевые слова : ~typename~ ИЛИ ~class~ (они означают одно и то же). Типу параметра шаблона можно присваивать значение по-умолчанию.

    * ~template<typename T>~ означает Для всех типов Т.

  2. Шаблон ф-ции == Алгоритм ->

     * Компилятор определяет параметры шаблона ф-ции по фактическим параметрам ф-ции. Но вообще : ~Ф-ция<параметры_шаблона>(фактические_параметры)~

**** Мейерс

Параметр шаблона ф-ции выводится (deduced) из типа переданных в ф-цию параметров.


*** Статический полиморфизм -> Перегрузка ф-ций и методов

- Левый операнд вызывает перегруженный оператор (метод с особым идентификатором), правый операнд передается в него.

**** Оператор присваивания = -> копирование

- Поверхностное копирование

- Оператор присваивания создает копию объекта.
  % Для вектора : ~v2.size()==v1.size() И v2[i]==v1[i]~


*** Динамический полиморфизм -> Переопределение методов в производных классах (Виртуальные ф-ции)

Виртуальные методы позволяют реализовать динамический полиморфизм, ведь указатели на производные классы совместимы по типу с указателем на базовый класс.

Абстрактный класс может существовать только как уровень иерархии классов.
- Объявление чистой виртуальной ф-ции делает класс абстрактным.


** TODO <2023-11-22 Wed> Наследование

Вызвать конструктор базового класса можно в списке инициализаторов конструктора производного.

В производном классе можно переопределять методы с теми же именами что и у методов базового класса.


** Виртуальные ф-ции

- Перекрытие (override) виртуальной ф-ции :: Механизм, делающий возможным вызов ф-ции производного класса через интерфейс базового класса.




* STL

** Контейнеры

*** vector

Динамический массив, на которым определены различные операции

- reserve(n) :: выделяет неинициализированную область памяти под newalloc элементов. С помощью этого метода нельзя уменьшить объем (capacity) вектора, что гарантирует актуальность ссылок и указателей.
#+BEGIN_SRC C++
/* Сильно упрощенная версия */
template <typename T>
void reserve(int newalloc) {
    if (newalloc <= space) return ;
    T* p = new T[newalloc] ;

    for (int i=0; i<sz; ++i) {
      p[i] = elem[i];
    }

    delete[] elem;

    elem = p; space = newalloc;
    // p Выбросит из стрека после выполнения следующей инструкции
}
#+END_SRC

- clear() :: Удаляет (erases) все элементы из вектора. Размер  (size) вектора становится равным нулю, объем (capacity) вектора не меняется.

- emplace_back(параметры_конструктора) :: Вызывает соответствующий списку параметров конструктор элемента индексом size() внутреннего динамического массива вектора.

** Алгоритмы

Определены в заголовочном файле <algorithm>

*** copy

Копирует элементы последовательности, определяемой парой итераторов [fist, last) в другую последовательность, определенную итератором, указывающим на ее первый элемент.
+ Тип входной последовательности может отличаться от типа выходной последовательности.
+ Алгоритм, в отличие от ф-ции ~memcopy()~, универсален.
+ Не проверяет диапазоны на допустимость, результирующая последовательность должна содержать хотя бы ~end-first~ элементов.

~std::copy(итератор_типа1 first, итератор_типа1 end, итератор_типа2 dest_first)~

~std::copy_if(тоже самое, предикат)~
+ Копирует только те элементы для которых предикат возвращает истину (передается указатель на булеву функцию).


* DONE <2023-10-19 Thu> For-each

Это цикл, который проходит по всем элементам коллекции

#+BEGIN_SRC C++
  for (const auto& i : коллекция) {
    //Инструкции
  }
#+END_SRC

Неизменяемая ссылка на элемент коллекции позволяет избежать вызова копирующего конструктора и деструктора для каждого из элементов коллекции.

Без использования ссылки инструкции в теле цикла будут оперировать локальными копиями элементов вектора и ни одна из операций над его компонентами не фактически не изменит их.

Эффективная ф-ция вывода элментов коллекции :
#+BEGIN_SRC C++
for (const auto& el : коллекция) {
  cout << el << " ";
}
#+END_SRC

Можно использовать для эффективного перебора списка инициализаторов ~std::initializer_list<>~


* Шаблоны

Специализации шаблона всегда пишут в области видимости протсрантсва имен, а не класса, в котором он объявлен.
