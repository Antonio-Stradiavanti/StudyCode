#+startup: overveiw
* Терминология

- View классы предназначены только для отображения информации.

- functor :: Имя метода или ф-ции.

- underlying platform :: Базовая платформа

- widget :: Элемент графического интерфейса.

- Событие :: Результат любого взаимодействия пользователя с элементами интерфейса : нажатие кнопки, перемещение мыши и т. п.

- pixmap :: Пиксельное изображение.

- Qt Assistant :: Встроенная документация



* Кроссплатформенность.

Для того чтобы запустить Qt приложение нужно получить исполняемый файл для arm процессора, для этого нужно скомпилировать проект в Qt Creator.

Также в CMakeLists файл нужно добавить некоторые доп. настройки.


* Система ресурсов

Префикс ":" пути к файлу явно указывает что файл должен быть загружен из системы ресурсов Qt.

- Ресурс :: Это файл, используемый приложением на этапе выполнения % изображение, иконка.

  Используемые ресурсы описываются в XML файле с расширением ~.qrc~
  - После добавления ресурса необходимо сохранить файл.

  - Добавляемый ресурс лучше скопировать в папку проекта.


* Структура проекта

Все заголовочные файлы подключаем в заголовочном файле widget.h

Внешний вид приложения настраиваем в файле mainwindow.cpp или widget.cpp


* <2023-12-09 Sat> QCreator & QDesigner

В меню refactor можно сгенерировать геттеры и сеттеры для свойства.

Чтобы перейти к ф-ции в исходном файле нужно написать ~C-k m пространство_имен::имя_ф-ции~

- M-1, 2, ... :: Открыть одно из окон консоли

** Общие сведения

Информацию об ошибках можно посмотреть в разделе 3 "Application output".

Интегрирован в Qt Creator. Создает виджеты отдельно от исходного кода программы, созданные им виджеты интегруют с кодом, используя механизм сигналов и слотов.

! Доступ к виджетам формы, добавленных посредством qt designer можно получить с помощью объекта ~ui~.

Имеет 3 режима : Edit mode, Signal & slots mode, buddy mdoe, tab order editing mode.

Инструмент, ускоряющий процесс проектирования пользовательского интерфейса.

.ui файл написан на XML.

- callback :: Указатель на ф-цию.
  + Qt предоставляет альтернативу технологии callback - signal & slots


** Qt Creator Горячие клавиши

Привязать свободное сочетание клавиш к определенной команде можно в меню Environment->Keyboard.

- S-DEL :: Вырезать строку
- C-M-UP/DOWN :: Продублировать строку выше/ниже.
- C-S-RET :: Вставить строку выше текущей строки.
- C-L :: Перейти к строке

- C-S-UP/DOWN :: Переместить строку выше/ниже.
- C-S-R :: Переименовать идентификатор объекта.

- C-</> :: Свернуть/развернуть блок кода.
- C-S-D :: Отобразить сигнатуру ф-ции.
- C-]/[ :: Перейти к концу/началу блока.
- C-U :: Выделить текст в текущем блоке.

- C-SPC :: Вызвать code completion.

- M-y M-y :: Режим vim

- C-e o :: Переключиться между окнами.
- C-e 0 :: Закрыть текущее окно редактора.
- C-e 2 :: Разбить окно редактора по вертикали.
- C-e 3 :: Разбить окно редактора по горизонтали.

- C-r :: Выполнить сборку проекта
- C-1 :: Перекючиться в режим редактирования.
- C-2 :: Переключиться в режим проектирования.

- C-S-r :: Изменить идентификатор объекта.



** Style Sheet

Синтаксис : ~свойство: значение;~

Цвет можно задать как hex или rgb.

Настроить внешний вид виджетов можно с помощью синтакисиса css и ф-ции ~setStyleSheet~ или файла с расширением ~.qss~, путь к которому добавляют фиксируют в ~.qrs~ файле.


* Сигналы и слоты

Чтобы добавить обработчик события в qt designer нужно просто нажать "go to slot"

Объекты вз. друг с другом с помощью этого механизма.

- Сигнал (Signal) :: сообщение о том что состояние объекта изменилось, произошло определенное событие.

- Обработчик события (Slot) :: Ф-ция, которая обрабатывает определенный сигнал.
  + Событиям соответствуют сигналы. Определенный сигнал подается когда происходит соответствующее событие.

Слоты и сигналы (чаще всего библиотечные) связывают с помощью ф-ции :
#+BEGIN_SRC cpp
class Sample : public QWidget {
signals:
  void cppSignal(const QString& str) const;

public slots:
  void cppSlot(const QString& str) const {
    // Прописываем логику.
  }

}
// Через макросы
Sapmple::Sample()
{
    connect(
        QObject* адрес_отправителя,

        const chat* SIGNAL(название_сигнала()),

        QObject* адрес_получателя,

        const char*               SLOT(обработчик(список_параметров)),

        ConnectionType тип_связи
    );
// Через указатели
    connect(
        QObject* адрес_отправителя,

        &Тип_отправителя::Сигнал,

        QObject* адрес_получателя,
        &Тип_получателя::Имя_метода_обработчика,

        ConnectionType тип_связи
    );
}

#+END_SRC
- Связать объект с обработчиком можно только после того как он объявлен.

- Тип связи определяет : будет ли сообщение доставлено в слот немедлено или будет поставлено в очередь. Относится к многопоточному программированию.

- Сигналы и слоты объявляют в заговочном файле формы с помощью ключ слов signal и slot соотв.
  + Макрос Q_OBJECT облегчает работу с мех. сигналов и слотов.
  + Необходимо :
    1. Число аргументов сигнала не может быть меньше чем число аргументов его обработчика.

    2. Между типами аргументов должны быть определены неявные преобразования.

- Сигналы библиотечных классов описаны в их документации.

- Один сигнал можно связать с несколькими слотами, а также один слот можно связать с несколькими сигналами.

- В качестве слотов можно использовать лямбда ф-ции.

- SIGNAL & SLOT - макросы, при их использовании нельзя отловить ошибки во время компиляции.

Для кнопки : clicked()
Для зависимого переключателя (radio button) : toggled(bool)


* <2023-12-16 Sat> Графика & QPaint

GraphicsView используется для отрисовки оч большого числа элементов. В моей работе он не нужен.

- QPaintDevice :: Абстракция 2D пространства на котором можно рисовать используя QPainter. Базовый класс для всех объектов, которые можно нарисовать.

Экземпляры классов QPaint, QColor, QBrush, QPoint ... -> создают в стеке.
- Экземпляр класса ~QPointF~ можно сформировать из экземпляра ~QPoint~

** QPainter

Экземпляры классов ~QImage~ & ~QPixmap~ создают в стеке.

Класс ~QPaintDevice~ базовый класс для объектов, на которых можно рисовать, от него наследуют : QWidget (форма), QPixmap, QImage, QPicture.
- Для каждого устройства рисования нужно создать свой экземпляр класса ~QPainter~.

- Для рисования вне формы используют в основном используют классы : ~QImage~ & ~QPixmap~
  + ~QImage~ :: Оптимизирован для вывода и редактирования изображений.
    * Изображение всегда ограничено прямоугольником.

  + ~QPixmap~ :: Разработан и оптимизирован для рисования.

Класс ~QPainter~ используется для рисования на формах и других поверхностях рисования.
- Работает в собственной системе координат устройства рисования. Это прозрачный хост, который накладывается на определенный родительский элемент, на нем рисуют.
  + _Система координат_ устройства рисования имеет начало в левом верхнем углу, значения *x* увеличиваются _вправо_, а значения *y* -> _вниз_; единица измерения -> пиксель.

- Позволяет отображать геометрические фигуры, пиксельные изображения (трехмерные битовые массивы) и текст.
  + Обычно ресуют либо на QWidget, либо на QImage
  + Это слой, на котором можно рисовать все что угодно.

- Если поверхность рисования это форма, то ~QPainter~ вызывают внутри метода ~paintEvent()~, который принимает в качестве параметра указатель на класс ~QPaintEvent~, который отправляется виджетам, которым необходимо _выполнить перерисовку_.
  + ~QPaintEvent~ :: Содержит информацию об области ~region()~, кот. необходимо перерисовать.
  + Пересировка например выполняется при изменении размеров формы, при изменении положения формы на экране монитора.
    * Перерисовку можно выполнить вызвав ф-цию-слот ~update()~, которая планирует paint event.

*** Кисть и перо

*Кисть* используется для заливки фигуры, а *перо* -> для обводки фигуры.
- При рисовании пером с четным количеством пикселей пиксели будут отрисовываться симметрично вокруг математических точек
- При рисовании пером с НЕчетным количеством пикселей свободный пиксель будет справа и ниже математической точки, как в случае с одним пикселем.


*** Геометрические фигуры

- QRect И QRectF :: Представляют прямуогольники на плоскости, задаются парой точек : верняя левая и правая нижняя.
  + Второй вариант использует вещественные координаты.
  + Метод ~normalized()~ :: Гарантирует что ширина и высота прямоульника не будут отрицательными.

- ConvexPolygon :: выпуклый многоугольник, задается массивом точек.

*** Преобразование системой координат

- ~setWindow~ :: Позволяет задать смещение системы координат устройства рисования. Позвляет строго ограничить видимую зону, указать какое количество пикселей будет отображаться в окне.

- ~translate~ позволяет задать смещение точек системы координат.
  + т.е локально изменить координаты прорисовки, не меняя самого изображения.

Метод ~scale~ позволяет масштабировать систему координат экземпляра ~QPainter~.

Перечисленные выше методы позволяют сформировать матрицу перехода экземпляра ~QPainter~, которую можно сохранить с помощью метода ~save()~, а вернуть в исходное состояние с помощью метода ~restore()~.

Перечисление ~QPainter::RenderHints~ Содержит флаги ~QPainter~
- ~Antialiasing~ :: Движок должен сглаживать края примитивов, используя разные интенсивности цветов, пиксели будут отображаться *симметрично* по обе стороны от математичеки определенных точек.


** Система событий

Виртуальные методы выделяют курсивом.

События в Qt пр. классами, производные от абстрактного класса ~QEvent~, они могут быть обработаны любым экземпляром класса, производного от ~QObject~
- ~QPaintEvent, QResizeEvent, QMouseEvent, QKeyEvent~
- Каждое событие имеет связанные с ним тип и стандартный обработчик. Но программист может расширить функционал обработчика, *переопределив* соотв. метод в производном классе.
  + Все связанные с событиями обработчики - виртуальные ф-ции (имеют стандартную реализацию).

Когда происходит событие Qt создает экземпляр соответствующего класса, производного от ~QEvent~ и доставляет его экземпляру класса, проивзодного от ~QObject~, вызывая его ф-цию ~event~, которая вызывает обработчик доставленного события.

Для уникальных событий можно реализовать обработчик общего события ~QEvent~

*** QMouseEvent

Для получения событий мыши нужно переопределить обработчики событий, объявленные в классе ~QWidget~ : ~QWidget::mousePressEvent(), QWidget::mouseReleaseEvent(), QWidget::mouseDoubleClickEvent(), QWidget::mouseMoveEvent()~

Происходит когда нажата одна из кнопок мыши внутри виджета.
- Виджет будет продолжать получать события мыши пока не будет отпущена последняя нажатая кнопка мыши.


*** QPaintEvent

Чтобы рисовать на поверхности рисования необходимо переопределить ее метод ~paintEvent~.

Означает что необходимо выполнить перерисовку виджета.

Происходит когда вызывается ф-ция виджета ~update()~, т.е. необходимо выполнить перерисовку виджета.

*** QResizeEvent

Отправляется виджетам, размер которых был изменен.


** QPainterPath

Класс ~QPainterPath~ предоставляет контейнер для графических объектов.

В него можно добавлять прямоугольники, эллипсы и дуги

Ф-ции ~lineTo(), arcTo(), cubicTo(), quadTo()~ позволяют добавить к экземпляру ~QPainterPath~ линии и кривые.
- cubicTo(c1, c2, конечная_точка) :: Кривая Безье между текущей точкой пути и заданной конечной точкой.

- moveTo() :: Начинает новый подпуть и закрывает предыдущий. Переводит значение currentPosition пути без добавления компонента.


** QPrinter

Используется для рисования на принтере.

** QTextDocument -> Содержит форматированный текст

Метод ~setHTML~ Позвляет выводить HTML


* QDialog

Модальные диалоги не позволяют переключить фокус на главное окно.

Создать свой диалог можно создав класс, производный от QDialog
Вводимую в диалогах информацию сохраняют в свойствах, которую получают с пом. геттеров.

Диалог можно либо принять, либо отклонить.
- Диалог отклоняют, вызывая стат. метод ~reject~
- Диалог принимают, вызывая метод ~accept~

В обработчике кнопоки ok обрабатывают корректность введенных данных.

Метод ~exec()~ показывает диалог в модальном режиме.
Метод ~show()~ показывает диалог в обычно режиме, т. е. позволяет переключать фокус на гл. окно до того как закрыл диалог.
- Но в этом случае нужно прописывать связь между нажатой кнопкой и ее обработчиком.

- QFileDialog :: Позволяет выбирать файлы или каталоги.
  + getSaveFileName :: Возвращает абсолютный путь к выбранному пользователем файлу.
    * Требует указатель на родительский виджет чтобы расположить диалоговое окно по центру род. виджета.
    * Фильтры определяют то какие файлы будут отображаться в каталогах.
      - Фильтр :: строка ~Название фильтра 1 (множество доступных файлов, обычно *.расширение, *.другое_расширение);; другой фильтр~


* QDebug

qInfo, qCritical, ... -> макроопределения.
- qCritical :: Вызывает обработчик сообщений с сообщением о критическом событии, если обработчик сообщений не установлен, то сообщение выводится в ~stderr~.


* QGraphics View Framework

Поверхность для управления и взаимодействия с большим числом пользовательских друмерных графических элементов.

- QGraphicsView :: Отображает содержимое сцены.
  + Принимает события ввода с клавиатуры и мыши и преобразует их в события сцены.

- QGraphicsScene :: Формирует графические элементы, которые размещаются на ~QGraphicsView~
  + Позволяет управлять некоторыми состояниями элементов : выбор элемента, фокус.
  + Графические элементы добавляют с помощью метода ~addItem~

- QGraphicsItemGroup :: Группа слоев, на которые можно помещать различные элементы.
  + Так проще обращаться к каждому из слоев и настраивать его свойства.

- QGraphicsItem :: Базовый класс для графических элементов сцены.
  + Имеет свою систему координат, которую можно преобразовывать.


* Файловая система

~QIODevice~ базовый абстрактный класс для всех устройств ввода - вывода
- ~QFile~ используется для работы с текстовыми файлами на жестком диске

Созданный файл, если указанно (только его имя) будет хранится в каталоге, сод сборку проекта.

Любой открытый файл нужно проверять на ошибки, после работы его нужно закрыть.
- Перед открытием файла на чтение нужно проверять существование выбранного пути к файлу

Вывести информацию об ошибках в консоль можно с поп. ~QDebug~

Классы, ок. на Stream предоставляют удобный интерфейс для чтения и записи в файлы.
- В конструктор передают указатель на класс. пр. отктрытый текстовый или двоичный файл.
- Кодировка по умолчанию : utf-8.
- После записи в поток нужно выполнить операцию ~flush~ чтобы записать данные из буфера на диск.
- ~atEnd~ возвр. ~true~ если достигнут символ конца файла.

Открытый файл должен быть закрыт в любом случае.

- ~QByteArray~ :: Используют для эффективного считывания с-строк.


* Сериализация в XML

В качестве ~QIODevice~ можно использовать экз. удобного класса ~QFile~

Реализация DOM стандарта для XML !

Для работы с XML используют классы ~QXmlStreamReader/Writer~
