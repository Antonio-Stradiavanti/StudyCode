#+startup: overveiw
* Терминология

- functor :: Имя метода или ф-ции.

- underlying platform :: Базовая платформа

- widget :: Элемент графического интерфейса.

- Событие :: Результат любого взаимодействия пользователя с элементами интерфейса : нажатие кнопки, перемещение мыши и т. п.

- pixmap :: Пиксельное изображение.

- Qt Assistant :: Встроенная документация



* Кроссплатформенность.

Для того чтобы запустить Qt приложение нужно получить исполняемый файл для arm процессора, для этого нужно скомпилировать проект в Qt Creator.

Также в CMakeLists файл нужно добавить некоторые доп. настройки.


* Система ресурсов

Префикс ":" пути к файлу явно указывает что файл должен быть загружен из системы ресурсов Qt.

- Ресурс :: Это файл, используемый приложением на этапе выполнения % изображение, иконка.

  Используемые ресурсы описываются в XML файле с расширением ~.qrc~
  - После добавления ресурса необходимо сохранить файл.

  - Добавляемый ресурс лучше скопировать в папку проекта.


* Структура проекта

Все заголовочные файлы подключаем в заголовочном файле widget.h

Внешний вид приложения настраиваем в файле mainwindow.cpp или widget.cpp


* Классы

Все измеряется в пикселях.

- QLineEdit :: Поле, в которое можно ввести текст.

Классы Qt API используют ~QString~ вместо ~std::string~, так как ~QString~ использует кодировку ~UTF-16~.

** Абстрактный класс QLayout

- К виджету, пр. форму тоже нужно добавить layout.

- Коэффициент растяжения заставляет виждеты располагаться пропорционально, но не меньше чем их минимальный размер

Делят пространство родительского виджета на равные части, с учетом определенного расстояния между ними, каждый дочерний виджет заполняет выделенное ему пространство, layout и соответственно форму нельзя сделать меньше минимального размера ее компонентов с учетом расстояния между ними.

*** Виртуальные методы

- addWidget() :: Позвляет добавить элемент пользовательского интерфейса.

- addLayout() :: Позволяет добавить вложенный layout.

- addSpacing() :: Расстояние между компонентами

*** Производные классы

- QHBoxLayout :: Позволяет выровнять виджеты по горизонтали.

- QVBoxLayout :: Позволяет выровнять виджеты по горизонтали.

- QGridLayout :: Позвляет организовать виджеты в виде матрицы.



** Диалоги
Для диалоговых окон базовым является класс ~QDialog~.

- QFileDialog :: Позволяет выбирать файлы или каталоги.
  + getSaveFileName :: Возвращает абсолютный путь к выбранному пользователем файлу.
    * Требует указатель на родительский виджет чтобы расположить диалоговое окно по центру род. виджета.
    * Фильтры определяют то какие файлы будут отображаться в каталогах.
      - Фильтр :: строка ~Название фильтра 1 (множество доступных файлов, обычно *.расширение, *.другое_расширение);; другой фильтр~

- QFontDialog

- QColorDialog

- QMessageBox :: Используется для отображения сообщений об ошибках.

** QMainWindow

Каркас для построения пользовательского интерфейса приложения.

Для этого типа виджетов можно создать menuBar, toolBar & statusBar.
- В ~toolBar~ добавляют экземпляры класса ~QAction~ для быстрого доступа, там отображаются только иконки команд.
  + Размер всех иконок toolBar должен быть одинаковым.
  + ~QAction~ :: Абстракция для пользовательских команд, которые могут быть добавлены в различные компоненты пользовательского интерфейса.

Для элементов menu bar сигнал triggered без параметров означает простое нажатие.
- Просто Совокупность экземпляров класса ~QAction~.
  + Чтобы привязать к команде сочетание клавиш нужно просто установить значение свойству shortcut.


** QWidget



Базовый класс для всех элементов пользовательского интерфейса.

** QIcon

Создает массив пикселей по переданному пиксельному изображению.


* <2023-12-09 Sat> QCreator & QDesigner

В меню refactor можно сгенерировать геттеры и сеттеры для свойства.

** Общие сведения

Информацию об ошибках можно посмотреть в разделе 3 "Application output".

Интегрирован в Qt Creator. Создает виджеты отдельно от исходного кода программы, созданные им виджеты интегруют с кодом, используя механизм сигналов и слотов.

! Доступ к виджетам формы, добавленных посредством qt designer можно получить с помощью объекта ~ui~.

Имеет 3 режима : Edit mode, Signal & slots mode, buddy mdoe, tab order editing mode.

Инструмент, ускоряющий процесс проектирования пользовательского интерфейса.

.ui файл написан на XML.

- callback :: Указатель на ф-цию.
  + Qt предоставляет альтернативу технологии callback - signal & slots


** Qt Creator Горячие клавиши

Привязать свободное сочетание клавиш к определенной команде можно в меню Environment->Keyboard.

- S-DEL :: Вырезать строку
- C-M-UP/DOWN :: Продублировать строку выше/ниже.
- C-S-RET :: Вставить строку выше текущей строки.
- C-L :: Перейти к строке

- C-S-UP/DOWN :: Переместить строку выше/ниже.
- C-S-R :: Переименовать идентификатор объекта.

- C-</> :: Свернуть/развернуть блок кода.
- C-S-D :: Отобразить сигнатуру ф-ции.
- C-]/[ :: Перейти к концу/началу блока.
- C-U :: Выделить текст в текущем блоке.

- C-SPC :: Вызвать code completion.

- M-y M-y :: Режим vim

- C-e o :: Переключиться между окнами.
- C-e 0 :: Закрыть текущее окно редактора.
- C-e 2 :: Разбить окно редактора по вертикали.
- C-e 3 :: Разбить окно редактора по горизонтали.

- C-r :: Выполнить сборку проекта
- C-1 :: Перекючиться в режим редактирования.
- C-2 :: Переключиться в режим проектирования.

- C-S-r :: Изменить идентификатор объекта.


** Сигналы и слоты

Чтобы добавить обработчик события в qt designer нужно просто нажать "go to slot"

Объекты вз. друг с другом с помощью этого механизма.

- Сигнал (Signal) :: сообщение о том что состояние объекта изменилось, произошло определенное событие.

- Обработчик события (Slot) :: Ф-ция, которая обрабатывает определенный сигнал.
  + Событиям соответствуют сигналы. Определенный сигнал подается когда происходит соответствующее событие.

Слоты и сигналы (чаще всего библиотечные) связывают с помощью ф-ции :
#+BEGIN_SRC cpp
class Sample : public QWidget {
signals:
  void cppSignal(const QString& str) const;

public slots:
  void cppSlot(const QString& str) const {
    // Прописываем логику.
  }

}
// Через макросы
Sapmple::Sample()
{
    connect(
        QObject* адрес_отправителя,

        const chat* SIGNAL(название_сигнала()),

        QObject* адрес_получателя,

        const char*               SLOT(обработчик(список_параметров)),

        ConnectionType тип_связи
    );
// Через указатели
    connect(
        QObject* адрес_отправителя,

        &Тип_отправителя::Сигнал,

        QObject* адрес_получателя,
        &Тип_получателя::Имя_метода_обработчика,

        ConnectionType тип_связи
    );
}

#+END_SRC
- Связать объект с обработчиком можно только после того как он объявлен.

- Тип связи определяет : будет ли сообщение доставлено в слот немедлено или будет поставлено в очередь. Относится к многопоточному программированию.

- Сигналы и слоты объявляют в заговочном файле формы с помощью ключ слов signal и slot соотв.
  + Макрос Q_OBJECT облегчает работу с мех. сигналов и слотов.
  + Необходимо :
    1. Число аргументов сигнала не может быть меньше чем число аргументов его обработчика.

    2. Между типами аргументов должны быть определены неявные преобразования.

- Сигналы библиотечных классов описаны в их документации.

- Один сигнал можно связать с несколькими слотами, а также один слот можно связать с несколькими сигналами.

- В качестве слотов можно использовать лямбда ф-ции.

- SIGNAL & SLOT - макросы, при их использовании нельзя отловить ошибки во время компиляции.

Для кнопки : clicked()
Для зависимого переключателя (radio button) : toggled(bool)



** Style Sheet

Синтаксис : ~свойство: значение;~

Цвет можно задать как hex или rgb.

Настроить внешний вид виджетов можно с помощью синтакисиса css и ф-ции ~setStyleSheet~ или файла с расширением ~.qss~, путь к которому добавляют фиксируют в ~.qrs~ файле.


* <2023-12-16 Sat> Графика & QPaint

GraphicsView используется для отрисовки оч большого числа элементов. В моей работе он не нужен.

- QPaintDevice :: Абстракция 2D пространства на котором можно рисовать используя QPainter. Базовый класс для всех объектов, которые можно нарисовать.

Экземпляры классов QPaint, QColor, QBrush, QPoint ... -> создают в стеке.
- Экземпляр класса ~QPointF~ можно сформировать из экземпляра ~QPoint~

** QPainter

Экземпляры классов ~QImage~ & ~QPixmap~ создают в стеке.

Класс ~QPaintDevice~ базовый класс для объектов, на которых можно рисовать, от него наследуют : QWidget (форма), QPixmap, QImage, QPicture.
- Для каждого устройства рисования нужно создать свой экземпляр класса ~QPainter~.

- Для рисования вне формы используют в основном используют классы : ~QImage~ & ~QPixmap~
  + ~QImage~ :: Оптимизирован для вывода и редактирования изображений.
    * Изображение всегда ограничено прямоугольником.

  + ~QPixmap~ :: Разработан и оптимизирован для рисования.

Класс ~QPainter~ используется для рисования на формах и других поверхностях рисования.
- Работает в собственной системе координат устройства рисования. Это прозрачный хост, который накладывается на определенный родительский элемент, на нем рисуют.
  + _Система координат_ устройства рисования имеет начало в левом верхнем углу, значения *x* увеличиваются _вправо_, а значения *y* -> _вниз_; единица измерения -> пиксель.

- Позволяет отображать геометрические фигуры, пиксельные изображения (трехмерные битовые массивы) и текст.
  + Обычно ресуют либо на QWidget, либо на QImage
  + Это слой, на котором можно рисовать все что угодно.

- Если поверхность рисования это форма, то ~QPainter~ вызывают внутри метода ~paintEvent()~, который принимает в качестве параметра указатель на класс ~QPaintEvent~, который отправляется виджетам, которым необходимо _выполнить перерисовку_.
  + ~QPaintEvent~ :: Содержит информацию об области ~region()~, кот. необходимо перерисовать.
  + Пересировка например выполняется при изменении размеров формы, при изменении положения формы на экране монитора.
    * Перерисовку можно выполнить вызвав ф-цию-слот ~update()~, которая планирует paint event.

*** Кисть и перо

*Кисть* используется для заливки фигуры, а *перо* -> для обводки фигуры.
- При рисовании пером с четным количеством пикселей пиксели будут отрисовываться симметрично вокруг математических точек
- При рисовании пером с НЕчетным количеством пикселей свободный пиксель будет справа и ниже математической точки, как в случае с одним пикселем.


*** Геометрические фигуры

- QRect И QRectF :: Представляют прямуогольники на плоскости, задаются парой точек : верняя левая и правая нижняя.
  + Второй вариант использует вещественные координаты.
  + Метод ~normalized()~ :: Гарантирует что ширина и высота прямоульника не будут отрицательными.

- ConvexPolygon :: выпуклый многоугольник, задается массивом точек.

*** Преобразование системой координат

- ~setWindow~ :: Позволяет задать смещение системы координат устройства рисования. Позвляет строго ограничить видимую зону, указать какое количество пикселей будет отображаться в окне.

- ~translate~ позволяет задать смещение точек системы координат.
  + т.е локально изменить координаты прорисовки, не меняя самого изображения.

Метод ~scale~ позволяет масштабировать систему координат экземпляра ~QPainter~.

Перечисленные выше методы позволяют сформировать матрицу перехода экземпляра ~QPainter~, которую можно сохранить с помощью метода ~save()~, а вернуть в исходное состояние с помощью метода ~restore()~.

Перечисление ~QPainter::RenderHints~ Содержит флаги ~QPainter~
- ~Antialiasing~ :: Движок должен сглаживать края примитивов, используя разные интенсивности цветов, пиксели будут отображаться *симметрично* по обе стороны от математичеки определенных точек.


** Система событий

Виртуальные методы выделяют курсивом.

События в Qt пр. классами, производные от абстрактного класса ~QEvent~, они могут быть обработаны любым экземпляром класса, производного от ~QObject~
- ~QPaintEvent, QResizeEvent, QMouseEvent, QKeyEvent~
- Каждое событие имеет связанные с ним тип и стандартный обработчик. Но программист может расширить функционал обработчика, *переопределив* соотв. метод в производном классе.
  + Все связанные с событиями обработчики - виртуальные ф-ции (имеют стандартную реализацию).

Когда происходит событие Qt создает экземпляр соответствующего класса, производного от ~QEvent~ и доставляет его экземпляру класса, проивзодного от ~QObject~, вызывая его ф-цию ~event~, которая вызывает обработчик доставленного события.

Для уникальных событий можно реализовать обработчик общего события ~QEvent~

*** QMouseEvent

Для получения событий мыши нужно переопределить обработчики событий, объявленные в классе ~QWidget~ : ~QWidget::mousePressEvent(), QWidget::mouseReleaseEvent(), QWidget::mouseDoubleClickEvent(), QWidget::mouseMoveEvent()~

Происходит когда нажата одна из кнопок мыши внутри виджета.
- Виджет будет продолжать получать события мыши пока не будет отпущена последняя нажатая кнопка мыши.


*** QPaintEvent

Чтобы рисовать на поверхности рисования необходимо переопределить ее метод ~paintEvent~.

Означает что необходимо выполнить перерисовку виджета.

Происходит когда вызывается ф-ция виджета ~update()~, т.е. необходимо выполнить перерисовку виджета.

*** QResizeEvent

Отправляется виджетам, размер которых был изменен.


** QPainterPath

Класс ~QPainterPath~ предоставляет контейнер для графических объектов.

В него можно добавлять прямоугольники, эллипсы и дуги

Ф-ции ~lineTo(), arcTo(), cubicTo(), quadTo()~ позволяют добавить к экземпляру ~QPainterPath~ линии и кривые.
- cubicTo(c1, c2, конечная_точка) :: Кривая Безье между текущей точкой пути и заданной конечной точкой.

- moveTo() :: Начинает новый подпуть и закрывает предыдущий. Переводит значение currentPosition пути без добавления компонента.


** QPrinter

Используется для рисования на принтере.

** QTextDocument -> Содержит форматированный текст

Метод ~setHTML~ Позвляет выводить HTML


* QDialog

Модальные диалоги не позволяют переключить фокус на главное окно.

Создать свой диалог можно создав класс, производный от QDialog
Вводимую в диалогах информацию сохраняют в свойствах, которую получают с пом. геттеров.

Диалог можно либо принять, либо отклонить.
- Диалог отклоняют, вызывая стат. метод ~reject~
- Диалог принимают, вызывая метод ~accept~

В обработчике кнопоки ok обрабатывают корректность введенных данных.

Метод ~exec()~ показывает диалог в модальном режиме.
Метод ~show()~ показывает диалог в обычно режиме, т. е. позволяет переключать фокус на гл. окно до того как закрыл диалог.
- Но в этом случае нужно прописывать связь между нажатой кнопкой и ее обработчиком.


* Qt XML

В качестве ~QIODevice~ можно использовать экз. удобного класса ~QFile~

Реализация DOM стандарта для XML !

Для работы с XML используют классы ~QXmlStreamReader/Writer~
