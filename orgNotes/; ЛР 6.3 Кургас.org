* TODO Выбрать библиотеку С++ для парсинга XML, отработать сериализацию

* TODO Написать иерархию классов

XML файл это и есть справочник.

- [ ] Сформировать 2 уровня иерархии дочерних по отношению к классу "Условный знак" классов с множественным наследованием.

** Что такое координатная сетка в топографических картах

- Координатная сетка :: сетка квадратов, образованных километровыми линиями.

Масштаб карты определяет размер координатной сетки.


** Что означает virtual при объявлении производного класса ?

Каждый из производных классов по умолчанию наследует свою копию свойств (подобъект) базового класса А, в такой ситуации при множественном наследовании от производных от класса A классов возникнет неоднозначность при попытке обратиться к своству класса A.
- Для разрешения неоднозначности в объявлении производных класса используют ключевое слово ~virtual~, это значит что объявленные производные классы наследуют один общий подобъект базового класса.

** Что такое call back

* TODO Написать сериализацию для иерархии классов

* XML

Альтернатива XML - JSON.

** Документ XML является документом правильного формата (well-formed) если соответствует следующим правилам

Готовые библиотеки работают с документами XML правильного формата.

Атрибуты тегов указываются после имени открывающего тега % ~<point x="10" y="20" z="30"\>~ .

1. XML документ должен всегда начинаться с инструкции "xml prologue", которая явно определяет используемую кодировку : ~<?xml version="1.0" encoding="utf-8"?>~
   + Это правило решает проблему неявно определенной кодировки текстового файла.

2. Использование тегов решает проблему путаницы с поведением пробельных символов в разных ОС.
   + Тег :: инструкция, заключенная в угловые скобки, различают открывающий и закрывающий.

   + Так как структура XML документа представляет собой дерево => обязательно должен быть объявлен "корневой" тег аггрегирующий все остальные теги.

   + Каждому открывающему тегу должен соответствовать закрывающий тег.

   + Свойства :: Способ  хранения дополнительной общей информации (метаданных) о содержимом тега .

3. Теги не долны пересекаться
   + т.е. конструкция : ~<b><i></b></i>~ - недопустима.

4. Для того чтобы облегчить реализацию парсера символы <, >, ", ', заменяют на :
   + > :: ~&gt;~
   + < :: ~&lt;~

Таким образом : форматируя текстовый файл согласно этим правилам можно сформировать формат для любой задачи и делегировать парсинг текстовых файлов на библиотеку.


** Документ оформлен надлежащим с точки зрения синтаксиса образом (valid) если он прошел проверку на соответствие строгим правилам XML или DTD.

- XML :: Расширяемый язык разметки, способ создания форматов для разных областей.

Если файл оформлен согласно определенному формату, то можно легко извлечь из него полезную информацию.

XDS и DTD позволяют задать для пользовательского формата документа более строгие правила.
- XSD (XML Schema Definition) :: Стандартный набор правил, формально описывающих структуру универсального XML документа.
  + Позволяет задать формат полей.


** Парсинг xml файлов в С++, Стратегии работы с XML

1. DOM ( Document Object Model ) Объектная модель документа : парсер разбирает документ XML и создает в оперативной памяти структуру дерево, для каждого тега создается 2 вида элементов : *тег* и его *содержимое* ; понятно что каждый из них хранит /указатель/ на _родительский узел и список указателей на дочерние узлы_; экземпляр типа *тег* ДОПОЛНИТЕЛЬНО содержит _имя и асооциативный массив_, а *содержимое тега* просто хранит _значение_.
   + Не является эффективным для обработки простых структур, так структура занимает в 4 раза больше памяти чем XML документ, для сложных структур использование DOM оправдано.

2. SAX (Simple API for XML) : Выполняет последовательную обработку XML документа ничего не сохраняет, вызывает пользовательские ф-ции для обработки : открывающего и закрывающего тегов, и их содержимого.

Библиотеки : Xerces (Для документов, в полном объеме соответствующих спецификации XML), expat, PugiXML (больше подходит для моих нужд).


** Разбираюсь с PugiXML

- handle :: Обработчик

 - Project-Add_New_Item/Add_Existing_Item :: Добавить XML файл в проект visual studio.

- Перечисление ~pugi::xml_node_type~ представляет все типы библиотеки, тип ~node_element~ - тег, тип ~node_pcdata~ - текст, закл. в теге.

Считать/Записать xml-документ :
Добавить дочерний узел к определенному узлу XML файла можно с помощью методов :

Теги и атрибуты - двусвязные списки, для классов ~xml_node & xml_attribute~ определены итераторы.

*** XML документ хранится в памяти в виде древовидной структуры данных, корень дерева - экземпляр класса ~xml_document~, дерево состоит из одного или нескольких узлов типа ~xml_node~.

Конструктор по умолчанию создает дерево, сост. только из корневого узла. Состоит
- Статический метод ~xml_document::reset()~ удаляет все узлы (кроме корневого) из дерева.

.load_file("путь") :: Удаляет существующее дерево и формирует новое из файла.
- Путь к файлу может быть как абсолютным, так и относительным, должен быть записан в формате целевой операционной системы, он передается системной ф-ции, отв. за открытие файла.

.save_file("путь") ;

.append_child(), .text(), .append_attribute() ;

Экземпляры классов ~xml_node & xml_attrubute~ просто обработчики соответствующих узлов дерева документа, узлы нельзя создать не добавив их в какой-либо документ.


*** Экземпляр класса ~xml_node~ - обработчик узла XML документа (обертка указателя).

! Имена атрибутов и вложенных тегов чувствительны к регистру.
- ::next/previous_sibling("имя")
- ::child("имя")
- ::attribute("имя")

Если узел не имеет потомков или соседей, то соотв. метод вернет ~nullptr~

Имя и значение узла - строки (~char*~).
- Узел типа ~node_element~ - имеет имя, но не имеет значения, значение имеет узел типа ~node_pcdata~
  + ~char* ::child_value()~ (возвращает текст первого дочернего узла) или ~child_value(имя_узла)~ позволяет получить значение первого дочернего узла типа ~node_pcdata~ (представляет просто текст без угловых скобок).
  + Если дочерний узел - тег, _то метод вернет пустую строку._

*** Экземпляр класса ~xml_attribute~ - обработчик атрибута XML документа

- ~char* ::value()~ == ~char* ::as_string()~ возвращает массив символов, значение атрибута.
- ~::set_value()~  изменить значение атрибута.
- ~T ::as_T(T значение_по_умолчанию)~ возвращает значение по умолчанию типа T если значение атрибута - пустая строка.


*** Метод ~text()~ возвращает объект класса ~xml_text~, который предоставляет методы для работы с текстом некоторого узла.

- ~.set()~ изменяет текстовое значение узла, принимает значение любого из примитивных типов.

- ~.get()~ возвращает массив символов, предст. значение узла.
