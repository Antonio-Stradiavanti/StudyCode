* Сбор информации
- [ ] Прочитать все про шаблоны у Страуструпа
* Спецификация
- Цель работы :: Изучить механизм параметрического полиморфизма на основе создания и использования параметризованных классов.

- Задание кафедры :: Реализовать на С++ параметризованный класс "Матрица"
  + Типы элементов матрицы : множество объектов определенного типа, массив символов.
  + Необходимые операции : сложение матриц, разность матриц, сложение матрицы с символом, сложение символа с матрицей.
    * Операции осуществляются одной строкой.

* Терминология

- Параметрический полиморфизм :: Механизм, который позволяет использовать типы в качестве параметров ф-ции или класса.

- vector :: Общий динамический массив элементов типа Т. Страуструп рекомендует использовать его по умолчанию.

* Ход работы

- [ ] Сформировать матрицу случайных величин любого типа.
- Компилятор всегда инициализирует нулем переменные базовых типов (имитация конструктора по умолчанию).

** vector ?> Как добавить элемент в вектор экземпляров класса не используя указатели (Йосуттис)

! Чтобы инициализировать ячейку вектора прямо (без копирования) (как если бы использовал указатели) используй метод ~emplace_back()~.

Векторы можно сравнивать, тогда логическая операция будет вызываться для каждого из элементов

Универсальный конструктор :
#+BEGIN_SRC C++
    vector <Elem> v (n /* количество_элементов */, elem /* конструтор_для_каждого_из_них */) ;
#+END_SRC
- Если в универсальный конструктор передать только количество элементов n, то для каждого из n элементов будет вызван конструктор по умолчанию.

При удалении вектора фактический объем выделенной памяти не изменяется, поэтому соответствующая операция называется ~erase~.

Конструктор с итераторами копирует n-1 элементов из вектора v0 в вектор v1.
#+BEGIN_SRC C++
    vector <Elem> v1 (v0.begin() /* количество_элементов */, v0.begin() + n /* конструтор_для_каждого_из_них */) ;
#+END_SRC

*** Информация об объеме выделенной памяти и о количестве элементов

- capacity() :: Объем выделенной под вектор памяти (в количестве элементов).

*** Управление объемом памяти

- reserve(int n) :: Выделяет область памяти под n элементов, если n <= v.capacity(), то не делает ничего. Не инициализирует выделенную область памяти.

*** Задание новых элементов

- assign() :: Заменяет определенное множество старых элементов новыми.
  + Множество методов assign соответствует множеству конструкторов.

*** Прямой доступ к элементам

- at(i) :: Возвращает ссылку на элемент, с индексом i, вызывает исключение ~out_of_range~, если входной индекс не принадлежит множеству допустимых индексов вектора.

** Статические поля

- Статичское поле видимо только внутр
  и класса, время жизни == время работы программы.
  + Используются для хранения данных, совместно используемых объектами класса.
  #+BEGIN_SRC C++
    // Пример инициализации статического поля
    class foo { static int bar }; int foo::bar = 10;
  #+END_SRC

** Значения формальных параметров ф-ции по умолчанию

- Используются тогда когда при вызове ф-ции в списке фактических параметров отсутствуют значения этих
  параметров. Альтернатива наличию нескольких перегруженных ф-ций.
  + Определять значения по умолчанию можно лишь для крайних параметров в списке формальных параметров.
** ? Как вставить в вектор объект пользовательского класса.

- reserve() ::

- push_back() :: Передает элемент в контейнер по ссылке и увеличивает размер контейреа на 1.
  + Элемент должен быть предварительно создан.

- emplace_back() :: Создает объект в слоте контейнере
** ? Контейнеры
- Контейнер последовательности :: упорядоченная коллекция, в которой каждый элемент занимает определенную позицию, которая не зависит от значения элемента.
  + В STL : array, vector, deaue, list, forward_list.


* Контрольные вопросы

** ? Зачем нужны параметризованные классы
** ? Какой из механизмов ООП реализуется с использованием параметризованных классов
** ? Что такое шаблон класса
** ? Во сколько раз сокращается машинный код программы при использовании параметризованных классов
** ? Какого вида могут быть параметры при задании шаблона класса
** ? Контейнеры
- Контейнер последовательности :: упорядоченная коллекция, в которой каждый элемент занимает определенную позицию, которая не зависит от значения элемента.
  + В STL : array, vector, deaue, list, forward_list.
