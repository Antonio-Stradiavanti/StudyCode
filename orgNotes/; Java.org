* Терминология

- access modifier :: Уровень доступа.

- Параметр - формальный параметр, агрумент - фактический параметр.
  + В стек-фрейме выделяется память для хранения локальных значений фактических параметров.

- Единица компиляции :: файл с исходным кодом Java.

- varargs parameter :: Параметр с переменным числом аргументов

- jar (Java archive) :: Основан на формате ZIP,   архив, объединяет множество _классов_ (скомпилированных в байт-код исходных файлов), метаданных и ресурсов в один файл.
  + Позволяет среде выполнения Java выполнить развертывание приложения за один запрос.


* <2023-10-16 Mon> История языка

Java разработан из-за необходимости в архитектурно-нейтральном языке, на котором можно писать ПО, для бытовых электронных устройств.
  - Не обладает ни прямой, ни обратной совместимостью с С++, с создан для решения одних задач, С++ - для других.
  - С распространением интернета потребность в переносимом ПО только возросла, так как в сети необходимо и запускать одну и ту же программу на разных платформах.

В Java простой синтаксис и высокий уровень абстракции, НО нужно уметь использвать классы стандартных и сторонних библиотек.
Каждая программа на Java соответствует парадигме ООП.

Java чувствиетелен к регистру.

* <2023-11-15 Wed> Особенности языка и его отличия от С++

Все объекты являются ссылками, ссылка в Java это скрытый, неизменяемый указатель на объект.

Отсутствует возможность явного управления памятью => отсутствуют указатели. Памятью управляет сборщик мусора.
- Сборщик мусора автоматически освобождает память, занимаемую объектами, которые больше не доступны и не используются в программе.

Все объекты хранятся в динамической области памяти, которой управляет виртуальная машина Java (JVM).

a. Отсутствует автоматическое преобразование типов, несоответствие типов - ошибка времени компиляции.

b. Запрешено использование оператора безусловного перехода goto.

c. Индентификатор, вкл. ~-~ явл. недопустимым.

d. Все элементарные типы данных имеют строго определенный диапазон значений.

e. НЕТ беззнакового целого типа.

f. Для представления символов используется кодировка Unicode, первые 127 кодов выделены для символов кодировки ASCII.
   + => Тип char занимает 2 байта.


* ? Для чего сейчас применяется Java

Сечас Java в основном используется для написания сервлетов.

- Сервлет :: Программа, исполняется на сервере.
  + Используется для формирования динамически-создаваемого содержимого веб-страницы, на основе действий клиента (сервера), которая отправляется браузеру.

- , :: Означает список объявлений объектов одного типа.
- {} :: Групповой оператор, с его помощью объединяют от 2х инструкций в блоки.

* <2023-10-16 Mon> Байткод, JVM [0/1] [0%]

Байткод - Оптимизированный набор инструкций, предназнaченных для выполнения виртуальной машиной Java (интерпретатор байт-кода), которая является частью среды выполнения Java (JRE).

Использование виртуальной машины упрощает запуск программы на разных платформах, так как для каждой из них нужно реализовать только JVM, которая принимает один и тот же байт-код, это позволяет не переписывать компилятор для каждого типа процессоров.

Виртуальная машина позволяет создать ограниченную в ресурсах среду выполнения программы - песочницу, управляет выделенными ресурсами.

В состав JVM входит JIT компилятор для байт-кода, он позволяет скомпилировать во время выполнения (по запросу) часть байт кода в машинный код, с целью повышения производительности. Остальной байт-код интерпретируется.

* Скомпилировать и запустить программу на Java

> Скомпилировать -> вызывав для исходного файла компилятор ~javac~, Выполнить -> загрузить байткод в JVM, вызвать загрузчик ~java~.

Расширение файла с исходным кодом Java : ~.java~

- Программа javac :: Компилятор языка программирования Java, переводит исходный код на Java в инструкции виртуальной машины (байт код) Java.
  + Для каждого класса создает отдельный файл, с именем класса и расширением ~.class~.

- Программа java :: Программа запуска приложений Java, запускает среду выполнения Java, загружает указанный класс (файл с расшинением .class) или архив .jar в JVM. Метод main -> точка входа в программу, сост. из одного или нескольких классов.
  - Метод main должен :
    1. Быть открытым
    2. Быть статическим
    3. Принимать в качестве параметра массив типа String.
       + Хранит любые аргументы командной строки.


* Ввод и вывод

** Ввод

*** Шилдт

Класс Scanner содержится в пакете java.util, считывает текст из источника, который реализует интерфейс Readable, разбивает текст на лексемы по заданным разделителям и преобразует их в значения с помощью методов next ИЛИ с помощью регулярных выражений, определяющих формат входных данных.

** Вывод

*** Шилдт

- Статический метод println() :: Принимает строку, к строке можно добавить переменную элементарного типа с помощью перегруженного оператора ~+~, вставляет символ новой строки в поток вывода;
  + Если строка, добавленная в стандартный поток вывода не оканчивается символом новой строки, то следующая строка добавится в ту же строку стандратного потока вывода.

- print :: не вставляет символ новой строки в поток вывода.
* <2023-11-24 Fri> Синтаксис

- var == auto В С++ :: Механизм выведения типов локальных переменных, компилятор определяет тип переменной по типу ее инициализатора.

Массивы реализованы в виде объектов.
- Класс массив имеет свойство ~length~, кот хр. размер выделенной памяти, выраженной в числе элементов (как capacity у вектора в С++).

** Передача параметров в методы

В Java параметры в ф-цию передаются в зависимости от их типа :

1. Примитивные : В стекфрейме вызваной ф-ции создается копия агрумента.

2. Аггрегатные : В стекфрейме вызваной ф-ции создается копия ссылки.
   + Объявление экземпляра класса - объявление ссылки, т.е. : по значению передается ссылка на объект, таким образом : изменения объекта внутри метода влияют на объект, указанный в качестве аргумента.

Параметр ~T ... v~ определяет аргумент переменной длины, который является массивом типа T с именем v, метод ~v.length()~ позволяет узнать фактическое число агрументов .


** Операторы передачи управления потоком выполнения программы : break, continue, return.

1. Оператор ~break~ завершает выполнение цикла и передает управление следующей за групповым оператором цикла или переключателя инструкции. Используется для выхода из одного блока кода.
   - Существует расширенная форма : ~break метка~ - замена ~goto метка~ - передает управление следующей за меткой инструкции. Используется для *выхода* из нескольких блоков кода.
     + Управление передается инструкции следующей за групповым оператором блока с меткой.
     + Метка :: Идентификатор Java, за которым следует ~:~, используется для идентификации блока кода.

2. Оператор ~continue~ передает управление условному выражению, управляющему циклом, т.е. : цикл переходит на сл. итерацию.
   - Существует расширенная форма : ~continue метка~

3. Оператор ~return~ передает управление обратно вызывающего метода, из стека удаляется соответсвующий стек-фрейм.
   - ~return~ в методе ~main~ передаст управление среде выполнения Java.


** Циклы

Цикл ~for~ состоит из 3х частей, отделенных друг от друга оператором ; : инициализазиция счетчика, условие окончания цикла, изменение счетчика.
- Части цикла for могут быть пустыми.

Цикл ~for-each~ проходит по коллекции объектов C от начала до конца. На каждой итерации из коллекции извлекается один элемент и сохраняется в переменной цикла it.
- Тип переменной цикла it должен _совпадать_ или быть _совместимым_ с типом элементов коллекции.
- Является более универсальным для прохода по коллекции.
#+BEGIN_SRC java
    for (var it : C) {
        // Тело цикла
    }
#+END_SRC

** <2023-11-14 Tue> Type Wrappers (Обертки типов)

Примитивные типы в Java, в целях повышения эффективности использования ресурсов реализованы также как в С++, это именованные области памяти, доступные для записи и чтения, но библиотечные классы и алгоритмы работают только с объектами, таким образом в некоторых ситуациях необходимо объектное представление примитивных типов.

- Обертка типа (Type Wrapper) :: Объектное представление примитивного типа (инкапсулирует переменную примитивного типа и предоставляет методы для работы с ним).

- Doube, Float, Long, Integer, Short, Byte, Character, Boolean.

Иниициализировать объект одного из классов type wrapper можно либо с помощью статического метода ~valueOf()~, либо с помощью оператора ~=~, они принимают в качестве параметра литерал соответствующего примитивного типа.

Вообще нет необходимости явно создавать объект семейства классов type wrapper, так как компилятор Java предоставляет механизмы автоупаковки и автораспаковки, которые он выполняет всякий раз, когда примитивный тип должен быть преобразован в объект, и наоборот.


** WAIT Обработка исключений

Ключевые слова : try, catch, throw, throws, finally.

** <2023-11-14 Tue> Аннотации

- Аннотация :: Механизм *метаданных*, Дополнительная информация, включаемая в исходный код, которая не меняет семантику программы, но используется компилятором, анализатором кода и другими средствами автоматизации сборки или развертывания. Аннотировать можно любой тип объявлений языка. Аннотация (как и шаблон в С++) предшествует остальной части объявления.

  1. Для объявления используется ключ слово ~@interface~. Объявление аннотации по синтаксису сходно с объявлением класса, т.е. : объявление аннотации должно содержаться в одноименном исходном файле.
     * Аннотации состоят только из объявлений виртуальных методов.
     * Являются производными от интерфейса Annotation.

     #+BEGIN_SRC java
     /* Как объявить пользовательскую аннотацию в Java */
     @Target(ElementType.TYPE)
     // Перечисление ElementType указывает тип аннотации.
     @Retention(RetentionPolicy.RUNTIME) // в скобках указывается список инициализаторов членов, каждый инициализатор присваивается соответствующему члену.
     public @interface NewAnnotation {
     }
     #+END_SRC

  2. Объявление аннотации - объявление особого класса.

Аннотация ~@Override~ явно указывает компилятору что метод переопределяет метод базового класса.

Аннотация ~@Target~ применяется к пользовательским аннотациям и явно указывает тип объявлений языка, к которому можно применять данную аннотацию.

Аннотация ~@Retention~ устанавливает политику хранения пользовательской аннотации, которая определяет этапы на которых будет доступна аннотация.

- Внутри _перечисления_ ~RententionPolicy~ инкапсулированны 3 *политики хранения* : SOURCE, CLASS, RUNTIME.
  + CLASS :: успользуется по умолчанию, аннотация доступна в исходном коде и на этапе компиляции.
  + RUNTIME :: Обеспечивает доступность аннотации в исходном коде и во время компиляции и выполнения.
    * Информацию об аннотациях класса с такой политикой хранения можно запрашивать из других программ на Java посредством рефлексии.

- Рефлексия :: Средство, позв. получать информацию о классе во время выполнения.





* <2023-11-15 Wed> ООП
** <2023-11-03 Fri> Пакеты -> объявление и импорт

- Пакет :: Группа классов

Оператор ~package~ определяет пространство имен для всех классов, объявленных в данном исходном файле
- Если оператор ~package~ отсутствует, то идентификаторы классов помещаются в стандартный безымянный пакет.
Для хранения пакетов применяют каталоги имя каталога должно совпадать с именем пакета вплоть до регистра.
- Иерархия пакетов также должна быть отражена в файл. системе.

Пути к каталогам, содержащим пакеты нужно указать в переменной среды окружения ~classpath~ или в параметре загрузчика ~java -classpath~


** Икапсуляция : Классы и уровни доступа

В Java как и в С++ существуют 3 уровня доступа.

Класс определяет новый, аггрегатный тип данных.
Компилятор Java автоматически помещает каждый класс в отдельный файл с расширением ~.class~.
- Имя класса, содержащего метод ~main()~ должно совпадать с именем исходного файла вплоть до регистра.

Свойства == переменные экземпляра, каждый объект хранит свою, независимую копию этих переменных.

Метод ~main~ объявляется в классе для объявления точки входа в программу.

Оператор ~new~ выделяет динамическую область памяти под объект и возвращает адрес младшего байта выделенной области (как и в С++).
- _В Java все объекты хранятся в динамической области памяти_.

- Объявление переменной некоторого аггрегатного типа (без инициализации) - объявление *ссылки* (ссылка - скрытый, неизменяемый указатель) на соответсвующий тип.

- Выделенные ресурсы освобождаются автоматически сборщиком мусора.
  + Выделенная под объект память освобождается, после того как будет уничтожена последняя ссылка на него.

Оператор ~.~ исп. для доступа к членам объекта.

Конструктор по умолчанию, сгенерированный компилятором, инициализирует нулями все неинециализированные переменные.

- this :: Ссылка на объект, из которого вызван метод.
  + Может использоваться для явного доступа к свойствам с теми же именами что и у аргументов ф-ции, так как последние скрывают свойства.
  + Статический метод не может ссылаться на this, так как он ему не передается.

Ключевое слово ~final~ делает свойство класса неизменяемым.
- Финальное свойство должно быть инициализированно при объявлении или в конструкторе.
- Идентификаторы финальных свойств пишут капсом.

*** Статические члены класса

Для иницализации статических свойств класса объявляют блок ~static~, который выполняется в первую очередь.


*** Уровни доступа к членам класса : Открытый, Закрытый, Защищенный определяют доступность члена за пределами класса.

Объявление члена класса должно начинаться с объявления уровня доступа (без разделителя :).

Уровень доступа по умолчанию : Открытый в своем пакете.


*** Вложенные классы

Вложенный класс является членом объемлющего класса.

Нестатический Вложенный класс имеет доступ ко всем членам объемлющего класса.

Статический вложенный класс может ссылаться только на статические члены объемлющего класса.

Объемлющий класс не имеет доступа к членам вложенного.

Можно объявить локальный для блока (например : тела ф-ции) внутренний класс.

Применяются при обработке определенных типов событий.


** Наследование

Ключ слово ~extends~ обозначает отношение наследование, объявляемый класс наследует все члены другого класса.

Ключ слово ~super~ имеет 2 формы :

1. Вызывает конструктор базового класса
2. Исп. для доступа к его членам.

В Java не поддерживается множественное наследование.

В Java существует только открытый режим наследования, т.е : производный класс имеет доступ только к открытым и защищенным членам базового класса.

Ссылки на суперкласс и производные от него классы совместимы, т.е. : _ссылке на базовый класс можно присвоить ссылку на производный класс_, но используя ссылку на базовый класс нельзя получить доступ к локальным для производного класса свойствам.

** Перечисления

- Перечисление :: Особый класс, список именованных констант, объект перечисления может содержать только значения из списка значений, указанных при объявлени. Удобно использовать в операторе switch.
  + В Java перечисление может иметь конструктор и методы


* Библиотечные классы

** String

Строковый литерал тоже объект класса String

Объекты класса String неизменяемы.
