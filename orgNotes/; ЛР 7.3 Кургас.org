- handle :: Управляемый указатель.

* DONE Делегаты

- Multicast delegate :: Многоадресный делегат. Все делегаты в C++/CLI -> многоадрессные

- Делегат :: Класс, который представляет указатель на ф-цию. В .NET фреймоврке введены чтобы абстрагироваться от особенностей языков, так как в C++ есть указатели на ф-ции, а VB например нет.

  + Задача : вызвать один или несколько методов с определенной сигнатурой.  Combine или Remove и  += и -=.
    * Каждый делегат имеет список вызовов, им управляют с помощью методов : ~Combine()/Remove()~ или соответсвующих им перегруженных операторов ~+=/-=~
      - Этот список вызовов можно даже перебрать в цикле for_earch, используя метод ~GetInvocationList()~

    * Если к делегату привязывают статический метод, то в его конструктор передают полное имя этого метода.

    * Если к делегату привязывают обычный метод, то в конструктор делегата помимо метода передают ссылку на объект из которого этот метод должен быть вызван.

  + Посредством делегатов можно вызывать только методы управляемых классов.

  + Привязанную к делегату ф-цию вызывают с помощью метода ~Invoke~, но вместо него обычно исп. оператор ~()~.

  + Делегат должен быть открытым чтобы к нему можно было привязывать методы.

  + Являются основой механизма событий, так как определяет сигнатуру обработчика события.
    * В одином классе определяют делегат, а в другом добавляют к нему методы и исп. и выз. их.


  + Указатель на ф-цию хранит адрес первой инструкции ф-ции.
    * С помощью указателя на ф-цию можно вызывать любые ф-ции с соответсвующей сигнатурой.
    * Имя ф-ции - адрес точки входа в ф-цию (первой инструкции ф-ции). Ф-ция завершается когда выполняется оператор ~return~.

#+BEGIN_SRC cpp
    delegate сигнатура_функции
#+END_SRC


* DONE События -> Источники публикуют события, получатели подписываются на них.

- fire the event :: Запустить событие.

- Событие :: Формализованный стандартный, основанный на *делегатах* механизм, который связывает источник события % кнопку, с его получателем % формой. Средство, с помощью которого экз. одного класса может уведомить экз. другого о том что произошло определенное событие.

  + Алгоритм
    1. Источник события (класс) объявляет делегат для каждого события, которое он может вызвать И методы, вызывающие события.

    2. Получатель события определяет подходящие с точки зрения сигнатуры методы.

    3. С помощью указателя на класс, в котором определены события, создают экземпляры соответствующих событиям делегатов, добавляют в их списки вызовов указатели на методы, обр. события.

       Созданные делегаты будут вызваны для конкретного экземпляра при запуске события.

  + Cобытия объявляют либо как свойства классов имеющие тип указатель на делегат. Для объявленного события неявно определяются методы ~add, remove, raise~, сигнатура и тип возвращаемого значения которых соответствует делегату.

  + События используют делегаты для обеспечения базового механизма, но при этом немного изменяют их поведение чтобы решить 2 проблемы, св. с исп. делегатов :
    1. _Проблема_ : любой может вызвать метод Invoke() *делегата*;
       _Решение_ : *событие* может быть вызвано только экземпляром класса, в котором оно объявлено.

    2. _Проблема_ : Получатель может присвоить многоадресному делегату ссылку на метод с помощью оператора ~=~ что сбросит список вызовов до одного элемента.
       _Решение_ : Получатели не могут сбросить список вызовов делегата, а могут только добавлять и удалять адреса опр. обработчиков с помощью операторов += и -=.

  + Событие и его обработчики часто объявляются в разных классах.

#+BEGIN_SRC cpp
   event тип_делегата^ имя_события;
#+END_SRC


 - [ ] Как передавать в события один или несколько параметров ?



* DONE Что такое обработчик события ?

- Обработчик события :: Просто метод, который выполняется при возникновении события.
  + Для создания связи между событием и обработчиком используется экземпляр делегата.

  + Для того чтобы метод обработал определенное событие его сигнатура должна совпадать с сигнатурой делегата, указанного при объявлении события.

- [ ] Как отслеживать наступление события



* DONE Ключ слова ref & value

  + ~ref class {};~ используется для объявления класса, время жизни экземпляров которого управляется средой ~CLR~ => экземпляры такого класса _всегда хранятся в куче_.
    * Если создать экземляр управляемого класса без использования указателей, то среда создаст его экземпляр в куче, но время жизни этого экземпляра будет ограничено блоком, в котором он объявлен.

    * Чтобы временем жизни экземляра управляемого класса управлял сборщик под него нужно явно выделить память с использованием оператора ~gcnew~, который возвращает  указатель на управляемый объект (обозначения используется символ ~^~) (на 1-й байт памяти, выделенной в управляемой сборщиком мусора куче)
      - В С++/CLI существуют 2 разные области динамической памяти, над одной из них определена сборка мусора, над другой нет.

  + ~value class {};~ используется для объявления класса, экземпляры которого хранятся в стеке, эквивалентно объявлению структуры в C#.
    * Экземпляр такого класса можно создать в куче только с использованием указателя на ~Object~

- В C++/CLI для вывода в консоль как в С# используются статические методы класса ~Console~

* Управляемые классы

Объект типа ~System.IO.TextReader~ представляет клавиатуру, а объект типа ~System.IO.TextWriter~ представляет окно консоли.

* Сборщик мусора

Среда выполнения NET выделяет память для управляемых объектов в особой области памяти. Она поделена на совокупности
