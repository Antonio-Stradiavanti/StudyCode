#include<iostream>
template <class T>
class vec {
  int sz; // Число элементов, elem + sz -> Ячейка памяти, следующая за последним элементом вектора
  T* elem; // Адрес нулевого элемента вектора
  int space; // Количество элементов + зарезервированная, но не инициализированная, область памяти для новых элементов типа T. Число байт памяти, выделенных под вектор.
public :
  // => Память не меняется, пока количество элементов не меняется.
  vec() : sz{0}, elem{nullptr}, space{0} {}

  // reserve(int число_новых_элементов) -> добавляет память для новых элементов. 
  void reserve(int newalloc) {
    if (newalloc <= space) return ;
    double* p = new double[newalloc] ;

    for (int i=0; i<sz; ++i) {
      p[i] = elem[i];
    }

    delete[] elem;

    elem = p;
    // p Выбросит из стрека после выполнения следующей инструкции
  }
  // Размер доступной памяти в объекте класса вектор, константный метод, не может изменять значение полей класса.
  int capacity() const { return space; }
};
int main() {
  return 0;
}